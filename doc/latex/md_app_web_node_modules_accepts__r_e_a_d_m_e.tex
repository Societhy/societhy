\href{https://npmjs.org/package/accepts}{\tt } \href{https://npmjs.org/package/accepts}{\tt } \href{http://nodejs.org/download/}{\tt } \href{https://travis-ci.org/jshttp/accepts}{\tt } \href{https://coveralls.io/r/jshttp/accepts}{\tt }

Higher level content negotiation based on \href{https://www.npmjs.com/package/negotiator}{\tt negotiator}. Extracted from \href{https://www.npmjs.com/package/koa}{\tt koa} for general use.

In addition to negotiator, it allows\+:


\begin{DoxyItemize}
\item Allows types as an array or arguments list, ie `(\mbox{[}\textquotesingle{}text/html\textquotesingle{}, \textquotesingle{}application/json\textquotesingle{}\mbox{]}){\ttfamily as well as}(\textquotesingle{}text/html\textquotesingle{}, \textquotesingle{}application/json\textquotesingle{}){\ttfamily .}
\item {\ttfamily Allows type shorthands such as}json{\ttfamily .}
\item {\ttfamily Returns}false{\ttfamily when no types match}
\item {\ttfamily Treats non-\/existent headers as}$\ast$`
\end{DoxyItemize}

\subsection*{Installation}


\begin{DoxyCode}
npm install accepts
\end{DoxyCode}


\subsection*{A\+PI}


\begin{DoxyCode}
var accepts = require('accepts')
\end{DoxyCode}


\subsubsection*{accepts(req)}

Create a new {\ttfamily Accepts} object for the given {\ttfamily req}.

\paragraph*{.charset(charsets)}

Return the first accepted charset. If nothing in {\ttfamily charsets} is accepted, then {\ttfamily false} is returned.

\paragraph*{.charsets()}

Return the charsets that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.encoding(encodings)}

Return the first accepted encoding. If nothing in {\ttfamily encodings} is accepted, then {\ttfamily false} is returned.

\paragraph*{.encodings()}

Return the encodings that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.language(languages)}

Return the first accepted language. If nothing in {\ttfamily languages} is accepted, then {\ttfamily false} is returned.

\paragraph*{.languages()}

Return the languages that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.type(types)}

Return the first accepted type (and it is returned as the same text as what appears in the {\ttfamily types} array). If nothing in {\ttfamily types} is accepted, then {\ttfamily false} is returned.

The {\ttfamily types} array can contain full M\+I\+ME types or file extensions. Any value that is not a full M\+I\+ME types is passed to `require(\textquotesingle{}mime-\/types\textquotesingle{}).lookup`.

\paragraph*{.types()}

Return the types that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\subsection*{Examples}

\subsubsection*{Simple type negotiation}

This simple example shows how to use {\ttfamily accepts} to return a different typed respond body based on what the client wants to accept. The server lists it\textquotesingle{}s preferences in order and will get back the best match between the client and server.


\begin{DoxyCode}
var accepts = require('accepts')
var http = require('http')

function app(req, res) \{
  var accept = accepts(req)

  // the order of this list is significant; should be server preferred order
  switch(accept.type(['json', 'html'])) \{
    case 'json':
      res.setHeader('Content-Type', 'application/json')
      res.write('\{"hello":"world!"\}')
      break
    case 'html':
      res.setHeader('Content-Type', 'text/html')
      res.write('<b>hello, world!</b>')
      break
    default:
      // the fallback is text/plain, so no need to specify it above
      res.setHeader('Content-Type', 'text/plain')
      res.write('hello, world!')
      break
  \}

  res.end()
\}

http.createServer(app).listen(3000)
\end{DoxyCode}


You can test this out with the c\+U\+RL program\+: 
\begin{DoxyCode}
curl -I -H'Accept: text/html' http://localhost:3000/
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 