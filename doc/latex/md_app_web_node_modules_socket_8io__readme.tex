\href{https://travis-ci.org/socketio/socket.io}{\tt } \href{https://david-dm.org/socketio/socket.io}{\tt } \href{https://david-dm.org/socketio/socket.io#info=devDependencies}{\tt } \href{https://www.npmjs.com/package/socket.io}{\tt }  \href{http://slack.socket.io}{\tt }

\subsection*{How to use}

The following example attaches socket.\+io to a plain Node.\+JS H\+T\+TP server listening on port {\ttfamily 3000}.


\begin{DoxyCode}
var server = require('http').createServer();
var io = require('socket.io')(server);
io.on('connection', function(client)\{
  client.on('event', function(data)\{\});
  client.on('disconnect', function()\{\});
\});
server.listen(3000);
\end{DoxyCode}


\subsubsection*{Standalone}


\begin{DoxyCode}
var io = require('socket.io')();
io.on('connection', function(client)\{\});
io.listen(3000);
\end{DoxyCode}


\subsubsection*{In conjunction with Express}

Starting with {\bfseries 3.\+0}, express applications have become request handler functions that you pass to {\ttfamily http} or {\ttfamily http} {\ttfamily Server} instances. You need to pass the {\ttfamily Server} to {\ttfamily socket.\+io}, and not the express application function.


\begin{DoxyCode}
var app = require('express')();
var server = require('http').createServer(app);
var io = require('socket.io')(server);
io.on('connection', function()\{ /* … */ \});
server.listen(3000);
\end{DoxyCode}


\subsubsection*{In conjunction with Koa}

Like Express.\+JS, Koa works by exposing an application as a request handler function, but only by calling the {\ttfamily callback} method.


\begin{DoxyCode}
var app = require('koa')();
var server = require('http').createServer(app.callback());
var io = require('socket.io')(server);
io.on('connection', function()\{ /* … */ \});
server.listen(3000);
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{Server}

Exposed by `require(\textquotesingle{}socket.\+io\textquotesingle{})`.

\subsubsection*{Server()}

Creates a new {\ttfamily Server}. Works with and without {\ttfamily new}\+:


\begin{DoxyCode}
var io = require('socket.io')();
// or
var Server = require('socket.io');
var io = new Server();
\end{DoxyCode}


\subsubsection*{Server(opts\+:\+Object)}

Optionally, the first or second argument (see below) of the {\ttfamily Server} constructor can be an options object.

The following options are supported\+:


\begin{DoxyItemize}
\item {\ttfamily serve\+Client} sets the value for Server\+::serve\+Client()
\item {\ttfamily path} sets the value for Server\+::path()
\end{DoxyItemize}

The same options passed to socket.\+io are always passed to the {\ttfamily engine.\+io} {\ttfamily Server} that gets created. See engine.\+io \href{https://github.com/socketio/engine.io#methods-1}{\tt options} as reference.

\subsubsection*{Server(srv\+:http\+::\+Server, opts\+:Object)}

Creates a new {\ttfamily Server} and attaches it to the given {\ttfamily srv}. Optionally {\ttfamily opts} can be passed.

\subsubsection*{Server(port\+:\+Number, opts\+:\+Object)}

Binds socket.\+io to a new {\ttfamily http.\+Server} that listens on {\ttfamily port}.

\subsubsection*{Server\+::serve\+Client(v\+:\+Boolean)\+:Server}

If {\ttfamily v} is {\ttfamily true} the attached server (see {\ttfamily Server\+::attach}) will serve the client files. Defaults to {\ttfamily true}.

This method has no effect after {\ttfamily attach} is called.


\begin{DoxyCode}
// pass a server and the `serveClient` option
var io = require('socket.io')(http, \{ serveClient: false \});

// or pass no server and then you can call the method
var io = require('socket.io')();
io.serveClient(false);
io.attach(http);
\end{DoxyCode}


If no arguments are supplied this method returns the current value.

\subsubsection*{Server\+::path(v\+:\+String)\+:Server}

Sets the path {\ttfamily v} under which {\ttfamily engine.\+io} and the static files will be served. Defaults to {\ttfamily /socket.io}.

If no arguments are supplied this method returns the current value.

\subsubsection*{Server\+::adapter(v\+:\+Adapter)\+:Server}

Sets the adapter {\ttfamily v}. Defaults to an instance of the {\ttfamily Adapter} that ships with socket.\+io which is memory based. See \href{https://github.com/socketio/socket.io-adapter}{\tt socket.\+io-\/adapter}.

If no arguments are supplied this method returns the current value.

\subsubsection*{Server\+::origins(v\+:\+String)\+:Server}

Sets the allowed origins {\ttfamily v}. Defaults to any origins being allowed.

If no arguments are supplied this method returns the current value.

\subsubsection*{Server\+::origins(v\+:\+Function)\+:Server}

Sets the allowed origins as dynamic function. Function takes two arguments {\ttfamily origin\+:String} and {\ttfamily callback(error, success)}, where {\ttfamily success} is a boolean value indicating whether origin is allowed or not.

{\bfseries Potential drawbacks}\+:
\begin{DoxyItemize}
\item in some situations, when it is not possible to determine {\ttfamily origin} it may have value of {\ttfamily $\ast$}
\item As this function will be executed for every request, it is advised to make this function work as fast as possible
\item If {\ttfamily socket.\+io} is used together with {\ttfamily Express}, the C\+O\+RS headers will be affected only for {\ttfamily socket.\+io} requests. For Express can use \href{https://github.com/expressjs/cors}{\tt cors}.
\end{DoxyItemize}

\subsubsection*{Server\+::sockets\+:Namespace}

The default ({\ttfamily /}) namespace.

\subsubsection*{Server\+::attach(srv\+:http\+::\+Server, opts\+:Object)\+:Server}

Attaches the {\ttfamily Server} to an engine.\+io instance on {\ttfamily srv} with the supplied {\ttfamily opts} (optionally).

\subsubsection*{Server\+::attach(port\+:\+Number, opts\+:\+Object)\+:Server}

Attaches the {\ttfamily Server} to an engine.\+io instance that is bound to {\ttfamily port} with the given {\ttfamily opts} (optionally).

\subsubsection*{Server\+::listen}

Synonym of {\ttfamily Server\+::attach}.

\subsubsection*{Server\+::bind(srv\+:engine\+::\+Server)\+:Server}

Advanced use only. Binds the server to a specific engine.\+io {\ttfamily Server} (or compatible A\+PI) instance.

\subsubsection*{Server\+::onconnection(socket\+:engine\+::\+Socket)\+:Server}

Advanced use only. Creates a new {\ttfamily socket.\+io} client from the incoming engine.\+io (or compatible A\+PI) {\ttfamily socket}.

\subsubsection*{Server\+::of(nsp\+:\+String)\+:Namespace}

Initializes and retrieves the given {\ttfamily Namespace} by its pathname identifier {\ttfamily nsp}.

If the namespace was already initialized it returns it immediately.

\subsubsection*{Server\+::emit}

Emits an event to all connected clients. The following two are equivalent\+:


\begin{DoxyCode}
var io = require('socket.io')();
io.sockets.emit('an event sent to all connected clients');
io.emit('an event sent to all connected clients');
\end{DoxyCode}


For other available methods, see {\ttfamily Namespace} below.

\subsubsection*{Server\+::close(\mbox{[}fn\+:\+Function\mbox{]})}

Closes socket.\+io server.

The optional {\ttfamily fn} is passed to the {\ttfamily server.\+close(\mbox{[}callback\mbox{]})} method of the core {\ttfamily net} module and is called on error or when all connections are closed. The callback is expected to implement the common single argument {\ttfamily err} signature (if any).


\begin{DoxyCode}
var Server = require('socket.io');
var PORT   = 3030;
var server = require('http').Server();

var io = Server(PORT);

io.close(); // Close current server

server.listen(PORT); // PORT is free to use

io = Server(server);
\end{DoxyCode}


\subsubsection*{Server\+::use}

See {\ttfamily Namespace\+::use} below.

\subsubsection*{Namespace}

Represents a pool of sockets connected under a given scope identified by a pathname (eg\+: {\ttfamily /chat}).

By default the client always connects to {\ttfamily /}.

\paragraph*{Events}


\begin{DoxyItemize}
\item {\ttfamily connection} / {\ttfamily connect}. Fired upon a connection.

Parameters\+:
\begin{DoxyItemize}
\item {\ttfamily Socket} the incoming socket.
\end{DoxyItemize}
\end{DoxyItemize}

\subsubsection*{Namespace\+::name\+:String}

The namespace identifier property.

\subsubsection*{Namespace\+::connected\+:Object$<$\+Socket$>$}

Hash of {\ttfamily Socket} objects that are connected to this namespace indexed by {\ttfamily id}.

\subsubsection*{Namespace\+::clients(fn\+:\+Function)}

Gets a list of client I\+Ds connected to this namespace (across all nodes if applicable).

An example to get all clients in a namespace\+:


\begin{DoxyCode}
var io = require('socket.io')();
io.of('/chat').clients(function(error, clients)\{
  if (error) throw error;
  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]
\});
\end{DoxyCode}


An example to get all clients in namespace\textquotesingle{}s room\+:


\begin{DoxyCode}
var io = require('socket.io')();
io.of('/chat').in('general').clients(function(error, clients)\{
  if (error) throw error;
  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]
\});
\end{DoxyCode}


As with broadcasting, the default is all clients from the default namespace (\textquotesingle{}/\textquotesingle{})\+:


\begin{DoxyCode}
var io = require('socket.io')();
io.clients(function(error, clients)\{
  if (error) throw error;
  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]
\});
\end{DoxyCode}


\subsubsection*{Namespace\+::use(fn\+:\+Function)\+:Namespace}

Registers a middleware, which is a function that gets executed for every incoming {\ttfamily Socket}, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.


\begin{DoxyCode}
var io = require('socket.io')();
io.use(function(socket, next)\{
  if (socket.request.headers.cookie) return next();
  next(new Error('Authentication error'));
\});
\end{DoxyCode}


Errors passed to middleware callbacks are sent as special {\ttfamily error} packets to clients.

\subsubsection*{Socket}

A {\ttfamily Socket} is the fundamental class for interacting with browser clients. A {\ttfamily Socket} belongs to a certain {\ttfamily Namespace} (by default {\ttfamily /}) and uses an underlying {\ttfamily Client} to communicate.

It should be noted the {\ttfamily Socket} doesn\textquotesingle{}t relate directly to the actual underlying T\+C\+P/\+IP {\ttfamily socket} and it is only the name of the class.

\subsubsection*{Socket\+::use(fn\+:\+Function)\+:Socket}

Registers a middleware, which is a function that gets executed for every incoming {\ttfamily Packet} and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.


\begin{DoxyCode}
var io = require('socket.io')();
io.on('connection', function(socket)\{
  socket.use(function(packet, next)\{
    if (packet.doge === true) return next();
    next(new Error('Not a doge error'));
\});
\end{DoxyCode}


Errors passed to middleware callbacks are sent as special {\ttfamily error} packets to clients.

\subsubsection*{Socket\+::rooms\+:Object}

A hash of strings identifying the rooms this client is in, indexed by room name.

\subsubsection*{Socket\+::client\+:Client}

A reference to the underlying {\ttfamily Client} object.

\subsubsection*{Socket\+::conn\+:Socket}

A reference to the underlying {\ttfamily Client} transport connection (engine.\+io {\ttfamily Socket} object). This allows access to the IO transport layer, which still (mostly) abstracts the actual T\+C\+P/\+IP socket.

\subsubsection*{Socket\+::request\+:Request}

A getter proxy that returns the reference to the {\ttfamily request} that originated the underlying engine.\+io {\ttfamily Client}. Useful for accessing request headers such as {\ttfamily Cookie} or {\ttfamily User-\/\+Agent}.

\subsubsection*{Socket\+::id\+:String}

A unique identifier for the session, that comes from the underlying {\ttfamily Client}.

\subsubsection*{Socket\+::emit(name\+:String\mbox{[}, …\mbox{]})\+:Socket}

Emits an event identified by the string {\ttfamily name} to the client. Any other parameters can be included.

All datastructures are supported, including {\ttfamily Buffer}. Java\+Script functions can\textquotesingle{}t be serialized/deserialized.


\begin{DoxyCode}
var io = require('socket.io')();
io.on('connection', function(client)\{
  client.emit('an event', \{ some: 'data' \});
\});
\end{DoxyCode}


\subsubsection*{Socket\+::join(name\+:\+String\mbox{[}, fn\+:\+Function\mbox{]})\+:Socket}

Adds the client to the {\ttfamily room}, and fires optionally a callback {\ttfamily fn} with {\ttfamily err} signature (if any).

The client is automatically a member of a room identified with its session id (see {\ttfamily Socket\+::id}).

The mechanics of joining rooms are handled by the {\ttfamily Adapter} that has been configured (see {\ttfamily Server\+::adapter} above), defaulting to \href{https://github.com/socketio/socket.io-adapter}{\tt socket.\+io-\/adapter}.

\subsubsection*{Socket\+::leave(name\+:\+String\mbox{[}, fn\+:\+Function\mbox{]})\+:Socket}

Removes the client from {\ttfamily room}, and fires optionally a callback {\ttfamily fn} with {\ttfamily err} signature (if any).

{\bfseries Rooms are left automatically upon disconnection}.

The mechanics of leaving rooms are handled by the {\ttfamily Adapter} that has been configured (see {\ttfamily Server\+::adapter} above), defaulting to \href{https://github.com/socketio/socket.io-adapter}{\tt socket.\+io-\/adapter}.

\subsubsection*{Socket\+::to(room\+:\+String)\+:Socket}

Sets a modifier for a subsequent event emission that the event will only be {\itshape broadcasted} to clients that have joined the given {\ttfamily room}.

To emit to multiple rooms, you can call {\ttfamily to} several times.


\begin{DoxyCode}
var io = require('socket.io')();
io.on('connection', function(client)\{
  client.to('others').emit('an event', \{ some: 'data' \});
\});
\end{DoxyCode}


\subsubsection*{Socket\+::in(room\+:\+String)\+:Socket}

Same as {\ttfamily Socket\+::to}

\subsubsection*{Socket\+::compress(v\+:\+Boolean)\+:Socket}

Sets a modifier for a subsequent event emission that the event data will only be {\itshape compressed} if the value is {\ttfamily true}. Defaults to {\ttfamily true} when you don\textquotesingle{}t call the method.


\begin{DoxyCode}
var io = require('socket.io')();
io.on('connection', function(client)\{
  client.compress(false).emit('an event', \{ some: 'data' \});
\});
\end{DoxyCode}


\subsubsection*{Socket\+::disconnect(close\+:\+Boolean)\+:Socket}

Disconnects this client. If value of close is {\ttfamily true}, closes the underlying connection. Otherwise, it just disconnects the namespace.

\paragraph*{Events}


\begin{DoxyItemize}
\item {\ttfamily disconnect}
\begin{DoxyItemize}
\item Fired upon disconnection.
\item {\bfseries Arguments}
\begin{DoxyItemize}
\item {\ttfamily String}\+: the reason of the disconnection (either client or server-\/side)
\end{DoxyItemize}
\end{DoxyItemize}
\item {\ttfamily error}
\begin{DoxyItemize}
\item Fired when an error occurs.
\item {\bfseries Arguments}
\begin{DoxyItemize}
\item {\ttfamily Object}\+: error data
\end{DoxyItemize}
\end{DoxyItemize}
\item {\ttfamily disconnecting}
\begin{DoxyItemize}
\item Fired when the client is going to be disconnected (but hasn\textquotesingle{}t left its {\ttfamily rooms} yet).
\item {\bfseries Arguments}
\begin{DoxyItemize}
\item {\ttfamily String}\+: the reason of the disconnection (either client or server-\/side)
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

These are reserved events (along with {\ttfamily connect}, {\ttfamily new\+Listener} and {\ttfamily remove\+Listener}) which cannot be used as event names.

\subsubsection*{Client}

The {\ttfamily Client} class represents an incoming transport (engine.\+io) connection. A {\ttfamily Client} can be associated with many multiplexed {\ttfamily Socket}s that belong to different {\ttfamily Namespace}s.

\subsubsection*{Client\+::conn}

A reference to the underlying {\ttfamily engine.\+io} {\ttfamily Socket} connection.

\subsubsection*{Client\+::request}

A getter proxy that returns the reference to the {\ttfamily request} that originated the engine.\+io connection. Useful for accessing request headers such as {\ttfamily Cookie} or {\ttfamily User-\/\+Agent}.

\subsection*{Debug / logging}

Socket.\+IO is powered by \href{https://github.com/visionmedia/debug}{\tt debug}. In order to see all the debug output, run your app with the environment variable {\ttfamily D\+E\+B\+UG} including the desired scope.

To see the output from all of Socket.\+IO\textquotesingle{}s debugging scopes you can use\+:


\begin{DoxyCode}
DEBUG=socket.io* node myapp
\end{DoxyCode}


\subsection*{Testing}


\begin{DoxyCode}
npm test
\end{DoxyCode}
 This runs the {\ttfamily gulp} task {\ttfamily test}. By default the test will be run with the source code in {\ttfamily lib} directory.

Set the environmental variable {\ttfamily T\+E\+S\+T\+\_\+\+V\+E\+R\+S\+I\+ON} to {\ttfamily compat} to test the transpiled es5-\/compat version of the code.

The {\ttfamily gulp} task {\ttfamily test} will always transpile the source code into es5 and export to {\ttfamily dist} first before running the test.

\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 