\subsection*{Usage}

\begin{DoxyVerb}$ npm install semver
$ node
var semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
\end{DoxyVerb}


As a command-\/line utility\+: \begin{DoxyVerb}$ semver -h

SemVer 5.1.0

A JavaScript implementation of the http://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
\end{DoxyVerb}


\subsection*{Versions}

A \char`\"{}version\char`\"{} is described by the {\ttfamily v2.\+0.\+0} specification found at \href{http://semver.org/}{\tt http\+://semver.\+org/}.

A leading {\ttfamily \char`\"{}=\char`\"{}} or {\ttfamily \char`\"{}v\char`\"{}} character is stripped off and ignored.

\subsection*{Ranges}

A {\ttfamily version range} is a set of {\ttfamily comparators} which specify versions that satisfy the range.

A {\ttfamily comparator} is composed of an {\ttfamily operator} and a {\ttfamily version}. The set of primitive {\ttfamily operators} is\+:


\begin{DoxyItemize}
\item {\ttfamily $<$} Less than
\item {\ttfamily $<$=} Less than or equal to
\item {\ttfamily $>$} Greater than
\item {\ttfamily $>$=} Greater than or equal to
\item {\ttfamily =} Equal. If no operator is specified, then equality is assumed, so this operator is optional, but M\+AY be included.
\end{DoxyItemize}

For example, the comparator {\ttfamily $>$=1.\+2.\+7} would match the versions {\ttfamily 1.\+2.\+7}, {\ttfamily 1.\+2.\+8}, {\ttfamily 2.\+5.\+3}, and {\ttfamily 1.\+3.\+9}, but not the versions {\ttfamily 1.\+2.\+6} or {\ttfamily 1.\+1.\+0}.

Comparators can be joined by whitespace to form a {\ttfamily comparator set}, which is satisfied by the {\bfseries intersection} of all of the comparators it includes.

A range is composed of one or more comparator sets, joined by {\ttfamily $\vert$$\vert$}. A version matches a range if and only if every comparator in at least one of the {\ttfamily $\vert$$\vert$}-\/separated comparator sets is satisfied by the version.

For example, the range {\ttfamily $>$=1.\+2.\+7 $<$1.\+3.\+0} would match the versions {\ttfamily 1.\+2.\+7}, {\ttfamily 1.\+2.\+8}, and {\ttfamily 1.\+2.\+99}, but not the versions {\ttfamily 1.\+2.\+6}, {\ttfamily 1.\+3.\+0}, or {\ttfamily 1.\+1.\+0}.

The range {\ttfamily 1.\+2.\+7 $\vert$$\vert$ $>$=1.\+2.\+9 $<$2.\+0.\+0} would match the versions {\ttfamily 1.\+2.\+7}, {\ttfamily 1.\+2.\+9}, and {\ttfamily 1.\+4.\+6}, but not the versions {\ttfamily 1.\+2.\+8} or {\ttfamily 2.\+0.\+0}.

\subsubsection*{Prerelease Tags}

If a version has a prerelease tag (for example, {\ttfamily 1.\+2.\+3-\/alpha.\+3}) then it will only be allowed to satisfy comparator sets if at least one comparator with the same {\ttfamily \mbox{[}major, minor, patch\mbox{]}} tuple also has a prerelease tag.

For example, the range {\ttfamily $>$1.\+2.\+3-\/alpha.\+3} would be allowed to match the version {\ttfamily 1.\+2.\+3-\/alpha.\+7}, but it would {\itshape not} be satisfied by {\ttfamily 3.\+4.\+5-\/alpha.\+9}, even though {\ttfamily 3.\+4.\+5-\/alpha.\+9} is technically \char`\"{}greater
than\char`\"{} {\ttfamily 1.\+2.\+3-\/alpha.\+3} according to the Sem\+Ver sort rules. The version range only accepts prerelease tags on the {\ttfamily 1.\+2.\+3} version. The version {\ttfamily 3.\+4.\+5} {\itshape would} satisfy the range, because it does not have a prerelease flag, and {\ttfamily 3.\+4.\+5} is greater than {\ttfamily 1.\+2.\+3-\/alpha.\+7}.

The purpose for this behavior is twofold. First, prerelease versions frequently are updated very quickly, and contain many breaking changes that are (by the author\textquotesingle{}s design) not yet fit for public consumption. Therefore, by default, they are excluded from range matching semantics.

Second, a user who has opted into using a prerelease version has clearly indicated the intent to use {\itshape that specific} set of alpha/beta/rc versions. By including a prerelease tag in the range, the user is indicating that they are aware of the risk. However, it is still not appropriate to assume that they have opted into taking a similar risk on the {\itshape next} set of prerelease versions.

\paragraph*{Prerelease Identifiers}

The method {\ttfamily .inc} takes an additional {\ttfamily identifier} string argument that will append the value of the string as a prerelease identifier\+:


\begin{DoxyCode}
> semver.inc('1.2.3', 'prerelease', 'beta')
'1.2.4-beta.0'
\end{DoxyCode}


command-\/line example\+:


\begin{DoxyCode}
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
\end{DoxyCode}


Which then can be used to increment further\+:


\begin{DoxyCode}
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
\end{DoxyCode}


\subsubsection*{Advanced Range Syntax}

Advanced range syntax desugars to primitive comparators in deterministic ways.

Advanced ranges may be combined in the same way as primitive comparators using white space or {\ttfamily $\vert$$\vert$}.

\paragraph*{Hyphen Ranges {\ttfamily X.\+Y.\+Z -\/ A.\+B.\+C}}

Specifies an inclusive set.


\begin{DoxyItemize}
\item {\ttfamily 1.\+2.\+3 -\/ 2.\+3.\+4} \+:= {\ttfamily $>$=1.\+2.\+3 $<$=2.\+3.\+4}
\end{DoxyItemize}

If a partial version is provided as the first version in the inclusive range, then the missing pieces are replaced with zeroes.


\begin{DoxyItemize}
\item {\ttfamily 1.\+2 -\/ 2.\+3.\+4} \+:= {\ttfamily $>$=1.\+2.\+0 $<$=2.\+3.\+4}
\end{DoxyItemize}

If a partial version is provided as the second version in the inclusive range, then all versions that start with the supplied parts of the tuple are accepted, but nothing that would be greater than the provided tuple parts.


\begin{DoxyItemize}
\item {\ttfamily 1.\+2.\+3 -\/ 2.\+3} \+:= {\ttfamily $>$=1.\+2.\+3 $<$2.\+4.\+0}
\item {\ttfamily 1.\+2.\+3 -\/ 2} \+:= {\ttfamily $>$=1.\+2.\+3 $<$3.\+0.\+0}
\end{DoxyItemize}

\paragraph*{X-\/\+Ranges {\ttfamily 1.\+2.\+x} {\ttfamily 1.\+X} {\ttfamily 1.\+2.$\ast$} {\ttfamily $\ast$}}

Any of {\ttfamily X}, {\ttfamily x}, or {\ttfamily $\ast$} may be used to \char`\"{}stand in\char`\"{} for one of the numeric values in the {\ttfamily \mbox{[}major, minor, patch\mbox{]}} tuple.


\begin{DoxyItemize}
\item {\ttfamily $\ast$} \+:= {\ttfamily $>$=0.\+0.\+0} (Any version satisfies)
\item {\ttfamily 1.\+x} \+:= {\ttfamily $>$=1.\+0.\+0 $<$2.\+0.\+0} (Matching major version)
\item {\ttfamily 1.\+2.\+x} \+:= {\ttfamily $>$=1.\+2.\+0 $<$1.\+3.\+0} (Matching major and minor versions)
\end{DoxyItemize}

A partial version range is treated as an X-\/\+Range, so the special character is in fact optional.


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}\char`\"{}} (empty string) \+:= {\ttfamily $\ast$} \+:= {\ttfamily $>$=0.\+0.\+0}
\item {\ttfamily 1} \+:= {\ttfamily 1.\+x.\+x} \+:= {\ttfamily $>$=1.\+0.\+0 $<$2.\+0.\+0}
\item {\ttfamily 1.\+2} \+:= {\ttfamily 1.\+2.\+x} \+:= {\ttfamily $>$=1.\+2.\+0 $<$1.\+3.\+0}
\end{DoxyItemize}

\paragraph*{Tilde Ranges {\ttfamily $\sim$1.2.\+3} {\ttfamily $\sim$1.2} {\ttfamily $\sim$1}}

Allows patch-\/level changes if a minor version is specified on the comparator. Allows minor-\/level changes if not.


\begin{DoxyItemize}
\item {\ttfamily $\sim$1.2.\+3} \+:= {\ttfamily $>$=1.\+2.\+3 $<$1.(2+1).0} \+:= {\ttfamily $>$=1.\+2.\+3 $<$1.\+3.\+0}
\item {\ttfamily $\sim$1.2} \+:= {\ttfamily $>$=1.\+2.\+0 $<$1.(2+1).0} \+:= {\ttfamily $>$=1.\+2.\+0 $<$1.\+3.\+0} (Same as {\ttfamily 1.\+2.\+x})
\item {\ttfamily $\sim$1} \+:= {\ttfamily $>$=1.\+0.\+0 $<$(1+1).0.\+0} \+:= {\ttfamily $>$=1.\+0.\+0 $<$2.\+0.\+0} (Same as {\ttfamily 1.\+x})
\item {\ttfamily $\sim$0.2.\+3} \+:= {\ttfamily $>$=0.\+2.\+3 $<$0.(2+1).0} \+:= {\ttfamily $>$=0.\+2.\+3 $<$0.\+3.\+0}
\item {\ttfamily $\sim$0.2} \+:= {\ttfamily $>$=0.\+2.\+0 $<$0.(2+1).0} \+:= {\ttfamily $>$=0.\+2.\+0 $<$0.\+3.\+0} (Same as {\ttfamily 0.\+2.\+x})
\item {\ttfamily $\sim$0} \+:= {\ttfamily $>$=0.\+0.\+0 $<$(0+1).0.\+0} \+:= {\ttfamily $>$=0.\+0.\+0 $<$1.\+0.\+0} (Same as {\ttfamily 0.\+x})
\item {\ttfamily $\sim$1.2.\+3-\/beta.\+2} \+:= {\ttfamily $>$=1.\+2.\+3-\/beta.\+2 $<$1.\+3.\+0} Note that prereleases in the {\ttfamily 1.\+2.\+3} version will be allowed, if they are greater than or equal to {\ttfamily beta.\+2}. So, {\ttfamily 1.\+2.\+3-\/beta.\+4} would be allowed, but {\ttfamily 1.\+2.\+4-\/beta.\+2} would not, because it is a prerelease of a different {\ttfamily \mbox{[}major, minor, patch\mbox{]}} tuple.
\end{DoxyItemize}

\paragraph*{Caret Ranges {\ttfamily $^\wedge$1.2.\+3} {\ttfamily $^\wedge$0.2.\+5} {\ttfamily $^\wedge$0.0.\+4}}

Allows changes that do not modify the left-\/most non-\/zero digit in the {\ttfamily \mbox{[}major, minor, patch\mbox{]}} tuple. In other words, this allows patch and minor updates for versions {\ttfamily 1.\+0.\+0} and above, patch updates for versions {\ttfamily 0.\+X $>$=0.\+1.\+0}, and {\itshape no} updates for versions {\ttfamily 0.\+0.\+X}.

Many authors treat a {\ttfamily 0.\+x} version as if the {\ttfamily x} were the major \char`\"{}breaking-\/change\char`\"{} indicator.

Caret ranges are ideal when an author may make breaking changes between {\ttfamily 0.\+2.\+4} and {\ttfamily 0.\+3.\+0} releases, which is a common practice. However, it presumes that there will {\itshape not} be breaking changes between {\ttfamily 0.\+2.\+4} and {\ttfamily 0.\+2.\+5}. It allows for changes that are presumed to be additive (but non-\/breaking), according to commonly observed practices.


\begin{DoxyItemize}
\item {\ttfamily $^\wedge$1.2.\+3} \+:= {\ttfamily $>$=1.\+2.\+3 $<$2.\+0.\+0}
\item {\ttfamily $^\wedge$0.2.\+3} \+:= {\ttfamily $>$=0.\+2.\+3 $<$0.\+3.\+0}
\item {\ttfamily $^\wedge$0.0.\+3} \+:= {\ttfamily $>$=0.\+0.\+3 $<$0.\+0.\+4}
\item {\ttfamily $^\wedge$1.2.\+3-\/beta.\+2} \+:= {\ttfamily $>$=1.\+2.\+3-\/beta.\+2 $<$2.\+0.\+0} Note that prereleases in the {\ttfamily 1.\+2.\+3} version will be allowed, if they are greater than or equal to {\ttfamily beta.\+2}. So, {\ttfamily 1.\+2.\+3-\/beta.\+4} would be allowed, but {\ttfamily 1.\+2.\+4-\/beta.\+2} would not, because it is a prerelease of a different {\ttfamily \mbox{[}major, minor, patch\mbox{]}} tuple.
\item {\ttfamily $^\wedge$0.0.\+3-\/beta} \+:= {\ttfamily $>$=0.\+0.\+3-\/beta $<$0.\+0.\+4} Note that prereleases in the {\ttfamily 0.\+0.\+3} version {\itshape only} will be allowed, if they are greater than or equal to {\ttfamily beta}. So, {\ttfamily 0.\+0.\+3-\/pr.\+2} would be allowed.
\end{DoxyItemize}

When parsing caret ranges, a missing {\ttfamily patch} value desugars to the number {\ttfamily 0}, but will allow flexibility within that value, even if the major and minor versions are both {\ttfamily 0}.


\begin{DoxyItemize}
\item {\ttfamily $^\wedge$1.2.\+x} \+:= {\ttfamily $>$=1.\+2.\+0 $<$2.\+0.\+0}
\item {\ttfamily $^\wedge$0.0.\+x} \+:= {\ttfamily $>$=0.\+0.\+0 $<$0.\+1.\+0}
\item {\ttfamily $^\wedge$0.0} \+:= {\ttfamily $>$=0.\+0.\+0 $<$0.\+1.\+0}
\end{DoxyItemize}

A missing {\ttfamily minor} and {\ttfamily patch} values will desugar to zero, but also allow flexibility within those values, even if the major version is zero.


\begin{DoxyItemize}
\item {\ttfamily $^\wedge$1.x} \+:= {\ttfamily $>$=1.\+0.\+0 $<$2.\+0.\+0}
\item {\ttfamily $^\wedge$0.x} \+:= {\ttfamily $>$=0.\+0.\+0 $<$1.\+0.\+0}
\end{DoxyItemize}

\subsubsection*{Range Grammar}

Putting all this together, here is a Backus-\/\+Naur grammar for ranges, for the benefit of parser authors\+:


\begin{DoxyCode}
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' | ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
\end{DoxyCode}


\subsection*{Functions}

All methods and classes take a final {\ttfamily loose} boolean argument that, if true, will be more forgiving about not-\/quite-\/valid semver strings. The resulting output will always be 100\% strict, of course.

Strict-\/mode Comparators and Ranges will be strict about the Sem\+Ver strings that they parse.


\begin{DoxyItemize}
\item {\ttfamily valid(v)}\+: Return the parsed version, or null if it\textquotesingle{}s not valid.
\item {\ttfamily inc(v, release)}\+: Return the version incremented by the release type ({\ttfamily major}, {\ttfamily premajor}, {\ttfamily minor}, {\ttfamily preminor}, {\ttfamily patch}, {\ttfamily prepatch}, or {\ttfamily prerelease}), or null if it\textquotesingle{}s not valid
\begin{DoxyItemize}
\item {\ttfamily premajor} in one call will bump the version up to the next major version and down to a prerelease of that major version. {\ttfamily preminor}, and {\ttfamily prepatch} work the same way.
\item If called from a non-\/prerelease version, the {\ttfamily prerelease} will work the same as {\ttfamily prepatch}. It increments the patch version, then makes a prerelease. If the input version is already a prerelease it simply increments it.
\end{DoxyItemize}
\item {\ttfamily prerelease(v)}\+: Returns an array of prerelease components, or null if none exist. Example\+: `prerelease(\textquotesingle{}1.\+2.\+3-\/alpha.\+1\textquotesingle{}) -\/$>$ \mbox{[}\textquotesingle{}alpha\textquotesingle{}, 1\mbox{]}{\ttfamily  $\ast$}major(v){\ttfamily \+: Return the major version number. $\ast$}minor(v){\ttfamily \+: Return the minor version number. $\ast$}patch(v)`\+: Return the patch version number.
\end{DoxyItemize}

\subsubsection*{Comparison}


\begin{DoxyItemize}
\item {\ttfamily gt(v1, v2)}\+: {\ttfamily v1 $>$ v2}
\item {\ttfamily gte(v1, v2)}\+: {\ttfamily v1 $>$= v2}
\item {\ttfamily lt(v1, v2)}\+: {\ttfamily v1 $<$ v2}
\item {\ttfamily lte(v1, v2)}\+: {\ttfamily v1 $<$= v2}
\item {\ttfamily eq(v1, v2)}\+: {\ttfamily v1 == v2} This is true if they\textquotesingle{}re logically equivalent, even if they\textquotesingle{}re not the exact same string. You already know how to compare strings.
\item {\ttfamily neq(v1, v2)}\+: {\ttfamily v1 != v2} The opposite of {\ttfamily eq}.
\item {\ttfamily cmp(v1, comparator, v2)}\+: Pass in a comparison string, and it\textquotesingle{}ll call the corresponding function above. {\ttfamily \char`\"{}===\char`\"{}} and {\ttfamily \char`\"{}!==\char`\"{}} do simple string comparison, but are included for completeness. Throws if an invalid comparison string is provided.
\item {\ttfamily compare(v1, v2)}\+: Return {\ttfamily 0} if {\ttfamily v1 == v2}, or {\ttfamily 1} if {\ttfamily v1} is greater, or {\ttfamily -\/1} if {\ttfamily v2} is greater. Sorts in ascending order if passed to {\ttfamily Array.\+sort()}.
\item {\ttfamily rcompare(v1, v2)}\+: The reverse of compare. Sorts an array of versions in descending order when passed to {\ttfamily Array.\+sort()}.
\item {\ttfamily diff(v1, v2)}\+: Returns difference between two versions by the release type ({\ttfamily major}, {\ttfamily premajor}, {\ttfamily minor}, {\ttfamily preminor}, {\ttfamily patch}, {\ttfamily prepatch}, or {\ttfamily prerelease}), or null if the versions are the same.
\end{DoxyItemize}

\subsubsection*{Ranges}


\begin{DoxyItemize}
\item {\ttfamily valid\+Range(range)}\+: Return the valid range or null if it\textquotesingle{}s not valid
\item {\ttfamily satisfies(version, range)}\+: Return true if the version satisfies the range.
\item {\ttfamily max\+Satisfying(versions, range)}\+: Return the highest version in the list that satisfies the range, or {\ttfamily null} if none of them do.
\item {\ttfamily min\+Satisfying(versions, range)}\+: Return the lowest version in the list that satisfies the range, or {\ttfamily null} if none of them do.
\item {\ttfamily gtr(version, range)}\+: Return {\ttfamily true} if version is greater than all the versions possible in the range.
\item {\ttfamily ltr(version, range)}\+: Return {\ttfamily true} if version is less than all the versions possible in the range.
\item {\ttfamily outside(version, range, hilo)}\+: Return true if the version is outside the bounds of the range in either the high or low direction. The {\ttfamily hilo} argument must be either the string `\textquotesingle{}$>$\textquotesingle{}{\ttfamily or}\textquotesingle{}$<$\textquotesingle{}{\ttfamily . (This is the function called by}gtr{\ttfamily and}ltr`.)
\end{DoxyItemize}

Note that, since ranges may be non-\/contiguous, a version might not be greater than a range, less than a range, {\itshape or} satisfy a range! For example, the range {\ttfamily 1.\+2 $<$1.\+2.\+9 $\vert$$\vert$ $>$2.\+0.\+0} would have a hole from {\ttfamily 1.\+2.\+9} until {\ttfamily 2.\+0.\+0}, so the version {\ttfamily 1.\+2.\+10} would not be greater than the range (because {\ttfamily 2.\+0.\+1} satisfies, which is higher), nor less than the range (since {\ttfamily 1.\+2.\+8} satisfies, which is lower), and it also does not satisfy the range.

If you want to know if a version satisfies or does not satisfy a range, use the {\ttfamily satisfies(version, range)} function. 