graceful-\/fs functions as a drop-\/in replacement for the fs module, making various improvements.

The improvements are meant to normalize behavior across different platforms and environments, and to make filesystem access more resilient to errors.

\subsection*{Improvements over \href{https://nodejs.org/api/fs.html}{\tt fs module}}


\begin{DoxyItemize}
\item Queues up {\ttfamily open} and {\ttfamily readdir} calls, and retries them once something closes if there is an E\+M\+F\+I\+LE error from too many file descriptors.
\item fixes {\ttfamily lchmod} for Node versions prior to 0.\+6.\+2.
\item implements {\ttfamily fs.\+lutimes} if possible. Otherwise it becomes a noop.
\item ignores {\ttfamily E\+I\+N\+V\+AL} and {\ttfamily E\+P\+E\+RM} errors in {\ttfamily chown}, {\ttfamily fchown} or {\ttfamily lchown} if the user isn\textquotesingle{}t root.
\item makes {\ttfamily lchmod} and {\ttfamily lchown} become noops, if not available.
\item retries reading a file if {\ttfamily read} results in E\+A\+G\+A\+IN error.
\end{DoxyItemize}

On Windows, it retries renaming a file for up to one second if {\ttfamily E\+A\+C\+C\+E\+SS} or {\ttfamily E\+P\+E\+RM} error occurs, likely because antivirus software has locked the directory.

\subsection*{U\+S\+A\+GE}


\begin{DoxyCode}
// use just like fs
var fs = require('graceful-fs')

// now go and do stuff with it...
fs.readFileSync('some-file-or-whatever')
\end{DoxyCode}


\subsection*{\hyperlink{class_global}{Global} Patching}

If you want to patch the global fs module (or any other fs-\/like module) you can do this\+:


\begin{DoxyCode}
// Make sure to read the caveat below.
var realFs = require('fs')
var gracefulFs = require('graceful-fs')
gracefulFs.gracefulify(realFs)
\end{DoxyCode}


This should only ever be done at the top-\/level application layer, in order to delay on E\+M\+F\+I\+LE errors from any fs-\/using dependencies. You should {\bfseries not} do this in a library, because it can cause unexpected delays in other parts of the program.

\subsection*{Changes}

This module is fairly stable at this point, and used by a lot of things. That being said, because it implements a subtle behavior change in a core part of the node A\+PI, even modest changes can be extremely breaking, and the versioning is thus biased towards bumping the major when in doubt.

The main change between major versions has been switching between providing a fully-\/patched {\ttfamily fs} module vs monkey-\/patching the node core builtin, and the approach by which a non-\/monkey-\/patched {\ttfamily fs} was created.

The goal is to trade {\ttfamily E\+M\+F\+I\+LE} errors for slower fs operations. So, if you try to open a zillion files, rather than crashing, {\ttfamily open} operations will be queued up and wait for something else to {\ttfamily close}.

There are advantages to each approach. Monkey-\/patching the fs means that no {\ttfamily E\+M\+F\+I\+LE} errors can possibly occur anywhere in your application, because everything is using the same core {\ttfamily fs} module, which is patched. However, it can also obviously cause undesirable side-\/effects, especially if the module is loaded multiple times.

Implementing a separate-\/but-\/identical patched {\ttfamily fs} module is more surgical (and doesn\textquotesingle{}t run the risk of patching multiple times), but also imposes the challenge of keeping in sync with the core module.

The current approach loads the {\ttfamily fs} module, and then creates a lookalike object that has all the same methods, except a few that are patched. It is safe to use in all versions of Node from 0.\+8 through 7.\+0.

\subsubsection*{v4}


\begin{DoxyItemize}
\item Do not monkey-\/patch the fs module. This module may now be used as a drop-\/in dep, and users can opt into monkey-\/patching the fs builtin if their app requires it.
\end{DoxyItemize}

\subsubsection*{v3}


\begin{DoxyItemize}
\item Monkey-\/patch fs, because the eval approach no longer works on recent node.
\item fixed possible type-\/error throw if rename fails on windows
\item verify that we {\itshape never} get E\+M\+F\+I\+LE errors
\item Ignore E\+N\+O\+S\+YS from chmod/chown
\item clarify that graceful-\/fs must be used as a drop-\/in
\end{DoxyItemize}

\subsubsection*{v2.\+1.\+0}


\begin{DoxyItemize}
\item Use eval rather than monkey-\/patching fs.
\item readdir\+: Always sort the results
\item win32\+: requeue a file if error has an OK status
\end{DoxyItemize}

\subsubsection*{v2.\+0}


\begin{DoxyItemize}
\item A return to monkey patching
\item wrap process.\+cwd
\end{DoxyItemize}

\subsubsection*{v1.\+1}


\begin{DoxyItemize}
\item wrap read\+File
\item Wrap fs.\+write\+File.
\item readdir protection
\item Don\textquotesingle{}t clobber the fs builtin
\item Handle fs.\+read E\+A\+G\+A\+IN errors by trying again
\item Expose the cur\+Open counter
\item No-\/op lchown/lchmod if not implemented
\item fs.\+rename patch only for win32
\item Patch fs.\+rename to handle AV software on Windows
\item Close \#4 Chown should not fail on einval or eperm if non-\/root
\item Fix isaacs/fstream\#1 Only wrap fs one time
\item Fix \#3 Start at 1024 max files, then back off on E\+M\+F\+I\+LE
\item lutimes that doens\textquotesingle{}t blow up on Linux
\item A full on-\/rewrite using a queue instead of just swallowing the E\+M\+F\+I\+LE error
\item Wrap Read/\+Write streams as well
\end{DoxyItemize}

\subsubsection*{1.\+0}


\begin{DoxyItemize}
\item Update engines for node 0.\+6
\item Be lstat-\/graceful on Windows
\item first 
\end{DoxyItemize}