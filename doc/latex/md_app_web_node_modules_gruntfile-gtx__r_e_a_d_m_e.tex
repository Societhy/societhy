\href{http://travis-ci.org/Bartvds/gruntfile-gtx}{\tt } \href{https://gemnasium.com/Bartvds/gruntfile-gtx}{\tt } \href{http://badge.fury.io/js/gruntfile-gtx}{\tt }

\begin{quote}
Turbo, spoilers and a sunroof for your Gruntfile. \end{quote}


\href{http://www.gruntjs.com}{\tt Grunt} enhancement to make gruntfile task management more dynamic and powerful. Handle demanding setups while keeping your Gruntfile shiny and D\+RY.

\subsection*{Features}


\begin{DoxyItemize}
\item Use macros to generate chains of related (semi-\/anonymous) plugin task instances.
\item Use tags to group and select similar targets.
\item Create new aliases by filtering tasks on various fields.
\item Transparently streamline gruntfile api a little.
\end{DoxyItemize}

Macros are powerful to define chains of targets for different plugins that together define a blueprint for build-\/sub-\/process. Create different instances that share or change parameters like identifiers, (partial) paths.

\subsubsection*{A\+PI Change}

Per {\ttfamily v0.\+1.\+0} the A\+PI was updated. The old docs can be found \href{https://github.com/Bartvds/gruntfile-gtx/commit/3472afa6546980e2a00933023c357dd516fcba2c}{\tt here}

\subsection*{Usage}

Check the \href{https://github.com/Bartvds/gruntfile-gtx/blob/master/Gruntfile.js}{\tt Gruntfile} for practical \href{https://en.wikipedia.org/wiki/Dogfooding}{\tt dogfooding} and \href{https://github.com/Bartvds/gruntfile-gtx/tree/master/test/spec}{\tt browse the tests} for some more options.

\subsubsection*{Example}


\begin{DoxyCode}
module.exports = function (grunt) \{

    // get the gtx instance
    var gtx = require('gruntfile-gtx').wrap(grunt);
\end{DoxyCode}


Load some plugins\+: 
\begin{DoxyCode}
gtx.loadNpm(
    'myPlugin',
    'myOtherPlugin'
);
//classic array
gtx.loadNpm([
    'myPlugin',
    'myOtherPlugin'
]);
// folder
gtx.loadTasks('./tasks');

// alternately load automatically (from ./tasks and ./node\_modules)
gtx.loadAuto();
\end{DoxyCode}


Build the grunt config like the regular structure\+: 
\begin{DoxyCode}
gtx.config(\{
    // read and blend objects
    pkg: gtx.readJSON('package.json', \{title: 'foo'\}, './conf/overwrite.json'),
    myPlugin: \{
        options: \{
            //..
        \},
        main: \{
            src: ['./files/main/*.js']
        \}
    \},
    myOtherPlugin: \{
        main: \{
            src: ['./files/dev/*.js']
        \}
    \}
\});
// ... but split over multiple statements
gtx.config(\{
    myPlugin: \{
        dev: \{
            src: ['./files/dev/*.js']
        \}
    \}
\});
// or directly set config objects
gtx.configFor('myPlugin', 'beta', \{
    src: ['./files/beta/*.js']
\});
\end{DoxyCode}


Define tasks\+: 
\begin{DoxyCode}
// define a simple task
gtx.call('say', function() \{
    grunt.log.writeln('hello!');
\});

// define a multi-task
gtx.multi('alpha\_multi', function() \{
    var options = this.options(\{
        //..
    \});
    grunt.log.writeln('hello!');
\});
\end{DoxyCode}


Run tasks\+: 
\begin{DoxyCode}
// named serial
gtx.alias('many', ['one', 'two', 'three']);

// named concurrent (max cpu cores)
gtx.concurrent('many', ['one', 'two', 'three']);
\end{DoxyCode}


Generate a unique name for a configuration (this is the basis for the macro feature) 
\begin{DoxyCode}
var name = gtx.configFor('myPlugin', \{
    src: ['./files/gamma/*.js']
\});

// do creative stuff by generating tasks (go wild here)
gtx.alias('bulk\_run', ['one', 'two', 'three'].map(function (name) \{
    return gtx.configFor('myPlugin', \{
        src: ['./files/' + name + '.js']
    \});
\}));

// generated tasks from parallel() to run concurrently
gtx.alias('many', ['one', gtx.parallel('two', 'three')]);

// generated tasks from serial()
gtx.alias('more', ['one', 
    gtx.parallel(
        gtx.serial('two', 'three'),
        gtx.serial('four', 'five'))
    )
]);
\end{DoxyCode}


This example is lifted from the \href{https://github.com/DefinitelyTyped/tsd/blob/develop-0.5.x/Gruntfile.js}{\tt gruntfile of T\+SD} and shows a macro to compile and run separated \textquotesingle{}test modules\textquotesingle{}. These can also be run concurrently to cut-\/down on overall test-\/duration for IO heavy topics.

Note how the macro uses a few plugins to setup and run\+: it would be a hassle to maintain these modules in a regular gruntfile but it is easy when using a macro to build the instance\+:


\begin{DoxyCode}
gtx.define('module\_tester', function (macro, id) \{
    // the macro object is a context with helpers to assemble a new instance named 'id'

    // let's use the instance id to build a shared path
    var testPath = 'test/modules/' + id + '/';

    // use grunt-contrib-clean to remove old test output
    macro.add('clean', [testPath + 'tmp/**/*']);

    // run a regular task
    macro.run('myPlugin:dev');

    // use grunt-ts to compile the TypeScript test cases
    macro.add('ts', \{
        options: \{\},
        src: [testPath + 'src/**/*.ts'],
        out: testPath + 'tmp/' + id + '.test.js'
    \});
    // use grunt-tslint
    macro.add('tslint', \{
        src: [testPath + 'src/**/*.ts']
    \});
    // optionally spawn a grunt-contrib-connect
    if (macro.getParam('http', 0) > 0) \{
        macro.add('connect', \{
            options: \{
                port: macro.getParam('http'),
                base: testPath + 'www/'
            \}
        \});
        //tag for easy retrieval
        macro.tag('http');
    \}
    // run grunt-mocha-test on the compiled test cases
    macro.add('mochaTest', \{
        options: \{
            timeout: macro.getParam('timeout', 2000)
        \},
        src: [testPath + 'tmp/**/*.test.js']
    \});
\}, \{
    // optionally run parallel using grunt-concurrent (for now only from gtx-type)
    concurrent: 4
\});
\end{DoxyCode}


Use the macro to make many similar instances\+: 
\begin{DoxyCode}
// use the macro to make many instances
gtx.create('git', 'module\_tester', null, 'lib');
gtx.create('tsd', 'module\_tester', \{timeout: 10000\}, 'lib,core');
gtx.create('http', 'module\_tester', \{
    timeout: 20000,
    http: 8080
\}, 'lib');
// bulk
gtx.create('basic,remote,local', 'module\_tester');
gtx.create(['basic','remote','local'], 'module\_tester');
\end{DoxyCode}


Mix functions and id\textquotesingle{}s\+: 
\begin{DoxyCode}
// mix calls in alias
gtx.alias('mix', ['alpha:one', 'bravo:two', function() \{
    grunt.log.writeln('roger');
\}, 'charlie', function() \{
    grunt.log.writeln('roger');
\}]);
\end{DoxyCode}


Finish up\+: 
\begin{DoxyCode}
    // let's make an alias to run all instances as your $ grunt test
    gtx.alias('test', 'gtx-type:module\_tester');

    // alias is short-cut for grunt.registerTask();
    gtx.alias('default', ['test']);

    // compile and send to grunt.initConfig()
    gtx.finalise();
\};
\end{DoxyCode}


To run these macro instances\+: 
\begin{DoxyCode}
$ grunt -h
$ grunt gtx:git
$ grunt gtx-group:core
$ grunt gtx-group:http
$ grunt gtx-type:module\_tester

// bonus: clean all
$ grunt clean
\end{DoxyCode}


\subsubsection*{Additional examples\+:}


\begin{DoxyItemize}
\item Complex example from \href{https://github.com/Bartvds/mocha-unfunk-reporter/blob/abc2732c1c44aca17dc8a7c647aa1f3d7313279e/Gruntfile.js}{\tt mocha-\/unfunk-\/reporter} uses a macro to setup a C\+LI output bulk tester (this is also a warning about power and responsibility).
\end{DoxyItemize}

\subsection*{Info}


\begin{DoxyItemize}
\item Your gruntfile is still a regular gruntfile to run by {\ttfamily grunt-\/cli}.
\begin{DoxyItemize}
\item Use the {\ttfamily grunt -\/h} command to view the generated tasks.
\item Main difference is to import and apply {\ttfamily gruntfile-\/gtx} on start if the Gruntfile.
\item Call {\ttfamily gtx.\+finalise()} at the end of the file to generate the config and apply aliases.
\end{DoxyItemize}
\item Generated aliases are prefixed with {\ttfamily gtx}, like {\ttfamily gtx-\/select\+:my\+Alias} or {\ttfamily gtx-\/group\+:dev}.
\begin{DoxyItemize}
\item They run like any task created by {\ttfamily grunt.\+register\+Task()}.
\end{DoxyItemize}
\item The extra A\+PI sugar like {\ttfamily gtx.\+load\+Npm()} is optional, but is generally D\+R\+Y-\/er then the regular versions.
\item String input uses a form of expansion and iteration where applicable.
\begin{DoxyItemize}
\item Split strings on separators to array\+: `gtx.alias(\textquotesingle{}name\textquotesingle{}, \textquotesingle{}one, two, three\textquotesingle{}){\ttfamily }
\item {\ttfamily  Nested arrays are flattened and the content split\+:}gtx.\+alias(\textquotesingle{}name\textquotesingle{}, \mbox{[}\mbox{[}\textquotesingle{}aa\textquotesingle{},\textquotesingle{}bb\textquotesingle{}\mbox{]}, \textquotesingle{}cc\textquotesingle{}, \mbox{[}\textquotesingle{}dd, ee\textquotesingle{}\mbox{]},\textquotesingle{}ff,gg,hh\textquotesingle{}\mbox{]}){\ttfamily }
\item {\ttfamily  Where grunt methods accept a single string the alias will iterate\+:}gtx.\+load\+Npm(\mbox{[}..\mbox{]})`
\end{DoxyItemize}
\item Gruntfile-\/gtx was grown organically\+: no gold-\/plating but some edges made shiny from wear.
\end{DoxyItemize}

\subsection*{Future}

There a lot of ideas for this floating around for this, from auto-\/dependency chains and non-\/repeating macro util tasks, to globbing helpers to generate macro instances and flows adapting to custom cli parameters or env variables. Also it would be cool to interface with (Yeoman) generators for easy instancing of build sub modules.

Most of these wait until Grunt reaches {\ttfamily 0.\+5.\+0} which solve some of the original problems.

\subsection*{A\+PI}

See above usage examples and look at the \href{https://github.com/Bartvds/gruntfile-gtx/blob/master/Gruntfile.js}{\tt Gruntfile} and \href{https://github.com/Bartvds/gruntfile-gtx/tree/master/test/spec}{\tt the tests} for more usage.

\section*{History}


\begin{DoxyItemize}
\item 0.\+3.\+0 -\/ Updated dependencies (thanks )
\item 0.\+2.\+5 -\/ Fixed {\ttfamily gtx.\+call()} and {\ttfamily macro.\+call()}.
\item 0.\+2.\+3 -\/ Fixed {\ttfamily gtx.\+multi()}, added {\ttfamily gtx.\+concurrent()}, {\ttfamily gtx.\+serial()}, {\ttfamily gtx.\+parallel()}
\item 0.\+2.\+2 -\/ Output fix.
\item 0.\+2.\+1 -\/ Added {\ttfamily macro.\+call()}, {\ttfamily gtx.\+call()}, {\ttfamily gtx.\+multi()}, added function support to {\ttfamily gtx.\+alias()}.
\item 0.\+1.\+1 -\/ Fixed some bugs
\item 0.\+1.\+0 -\/ Renamed some methods on {\ttfamily gtx} api, added {\ttfamily gtx.\+read\+J\+S\+O\+N()}/{\ttfamily gtx.\+read\+Y\+A\+M\+L()} helpers
\item 0.\+0.\+8 -\/ Cleaned task, small fixes, bundle \href{https://github.com/sindresorhus/load-grunt-tasks}{\tt load-\/grunt-\/tasks} (via {\ttfamily grunt.\+load\+Auto()})
\item 0.\+0.\+5 -\/ Added concurrent-\/execution to {\ttfamily gtx\+:type}
\item 0.\+0.\+3 -\/ N\+PM push
\item 0.\+0.\+2 -\/ Various construction work
\end{DoxyItemize}

\subsection*{Contributing}

Contributions are welcome (idiomatic, clean etc) but best to post a proposal in the \href{https://github.com/Bartvds/gruntfile-gtx/issues}{\tt Issues} before making big changes.

\subsection*{Vagrant}

There is a Vagrantfile and set of Chef cookbooks to use with \href{http://www.vagrantup.com}{\tt Vagrant} for easy testing on a Linux VM. It will install a node.\+js from package, install the dependencies and enable grunt.

\subsection*{License}

Copyright (c) 2013 Bart van der Schoor

Licensed under the M\+IT license.

\href{https://bitdeli.com/free}{\tt } 