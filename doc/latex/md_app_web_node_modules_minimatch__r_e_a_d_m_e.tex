A minimal matching utility.

\href{http://travis-ci.org/isaacs/minimatch}{\tt }

This is the matching library used internally by npm.

Eventually, it will replace the C binding in node-\/glob.

It works by converting glob expressions into Java\+Script {\ttfamily Reg\+Exp} objects.

\subsection*{Usage}


\begin{DoxyCode}
var minimatch = require("minimatch")

minimatch("bar.foo", "*.foo") // true!
minimatch("bar.foo", "*.bar") // false!
minimatch("bar.foo", "*.+(bar|foo)", \{ debug: true \}) // true, and noisy!
\end{DoxyCode}


\subsection*{Features}

Supports these glob features\+:


\begin{DoxyItemize}
\item Brace Expansion
\item Extended glob matching
\item \char`\"{}\+Globstar\char`\"{} {\ttfamily $\ast$$\ast$} matching
\end{DoxyItemize}

See\+:


\begin{DoxyItemize}
\item {\ttfamily man sh}
\item {\ttfamily man bash}
\item {\ttfamily man 3 fnmatch}
\item {\ttfamily man 5 gitignore}
\end{DoxyItemize}

\subsection*{Minimatch Class}

Create a minimatch object by instanting the {\ttfamily minimatch.\+Minimatch} class.


\begin{DoxyCode}
var Minimatch = require("minimatch").Minimatch
var mm = new Minimatch(pattern, options)
\end{DoxyCode}


\subsubsection*{Properties}


\begin{DoxyItemize}
\item {\ttfamily pattern} The original pattern the minimatch object represents.
\item {\ttfamily options} The options supplied to the constructor.
\item {\ttfamily set} A 2-\/dimensional array of regexp or string expressions. Each row in the array corresponds to a brace-\/expanded pattern. Each item in the row corresponds to a single path-\/part. For example, the pattern {\ttfamily \{a,b/c\}/d} would expand to a set of patterns like\+: \begin{DoxyVerb}  [ [ a, d ]
  , [ b, c, d ] ]
\end{DoxyVerb}


If a portion of the pattern doesn\textquotesingle{}t have any \char`\"{}magic\char`\"{} in it (that is, it\textquotesingle{}s something like {\ttfamily \char`\"{}foo\char`\"{}} rather than {\ttfamily fo$\ast$o?}), then it will be left as a string rather than converted to a regular expression.
\item {\ttfamily regexp} Created by the {\ttfamily make\+Re} method. A single regular expression expressing the entire pattern. This is useful in cases where you wish to use the pattern somewhat like {\ttfamily fnmatch(3)} with {\ttfamily F\+N\+M\+\_\+\+P\+A\+TH} enabled.
\item {\ttfamily negate} True if the pattern is negated.
\item {\ttfamily comment} True if the pattern is a comment.
\item {\ttfamily empty} True if the pattern is {\ttfamily \char`\"{}\char`\"{}}.
\end{DoxyItemize}

\subsubsection*{Methods}


\begin{DoxyItemize}
\item {\ttfamily make\+Re} Generate the {\ttfamily regexp} member if necessary, and return it. Will return {\ttfamily false} if the pattern is invalid.
\item {\ttfamily match(fname)} Return true if the filename matches the pattern, or false otherwise.
\item {\ttfamily match\+One(file\+Array, pattern\+Array, partial)} Take a {\ttfamily /}-\/split filename, and match it against a single row in the {\ttfamily reg\+Exp\+Set}. This method is mainly for internal use, but is exposed so that it can be used by a glob-\/walker that needs to avoid excessive filesystem calls.
\end{DoxyItemize}

All other methods are internal, and will be called as necessary.

\subsection*{Functions}

The top-\/level exported function has a {\ttfamily cache} property, which is an L\+RU cache set to store 100 items. So, calling these methods repeatedly with the same pattern and options will use the same Minimatch object, saving the cost of parsing it multiple times.

\subsubsection*{minimatch(path, pattern, options)}

Main export. Tests a path against the pattern using the options.


\begin{DoxyCode}
var isJS = minimatch(file, "*.js", \{ matchBase: true \})
\end{DoxyCode}


\subsubsection*{minimatch.\+filter(pattern, options)}

Returns a function that tests its supplied argument, suitable for use with {\ttfamily Array.\+filter}. Example\+:


\begin{DoxyCode}
var javascripts = fileList.filter(minimatch.filter("*.js", \{matchBase: true\}))
\end{DoxyCode}


\subsubsection*{minimatch.\+match(list, pattern, options)}

Match against the list of files, in the style of fnmatch or glob. If nothing is matched, and options.\+nonull is set, then return a list containing the pattern itself.


\begin{DoxyCode}
var javascripts = minimatch.match(fileList, "*.js", \{matchBase: true\}))
\end{DoxyCode}


\subsubsection*{minimatch.\+make\+Re(pattern, options)}

Make a regular expression object from the pattern.

\subsection*{Options}

All options are {\ttfamily false} by default.

\subsubsection*{debug}

Dump a ton of stuff to stderr.

\subsubsection*{nobrace}

Do not expand {\ttfamily \{a,b\}} and {\ttfamily \{1..3\}} brace sets.

\subsubsection*{noglobstar}

Disable {\ttfamily $\ast$$\ast$} matching against multiple folder names.

\subsubsection*{dot}

Allow patterns to match filenames starting with a period, even if the pattern does not explicitly have a period in that spot.

Note that by default, {\ttfamily a/$\ast$$\ast$/b} will {\bfseries not} match {\ttfamily a/.d/b}, unless {\ttfamily dot} is set.

\subsubsection*{noext}

Disable \char`\"{}extglob\char`\"{} style patterns like {\ttfamily +(a$\vert$b)}.

\subsubsection*{nocase}

Perform a case-\/insensitive match.

\subsubsection*{nonull}

When a match is not found by {\ttfamily minimatch.\+match}, return a list containing the pattern itself. When set, an empty list is returned if there are no matches.

\subsubsection*{match\+Base}

If set, then patterns without slashes will be matched against the basename of the path if it contains slashes. For example, {\ttfamily a?b} would match the path {\ttfamily /xyz/123/acb}, but not {\ttfamily /xyz/acb/123}.

\subsubsection*{nocomment}

Suppress the behavior of treating {\ttfamily \#} at the start of a pattern as a comment.

\subsubsection*{nonegate}

Suppress the behavior of treating a leading {\ttfamily !} character as negation.

\subsubsection*{flip\+Negate}

Returns from negate expressions the same as if they were not negated. (Ie, true on a hit, false on a miss.)

\subsection*{Comparisons to other fnmatch/glob implementations}

While strict compliance with the existing standards is a worthwhile goal, some discrepancies exist between minimatch and other implementations, and are intentional.

If the pattern starts with a {\ttfamily !} character, then it is negated. Set the {\ttfamily nonegate} flag to suppress this behavior, and treat leading {\ttfamily !} characters normally. This is perhaps relevant if you wish to start the pattern with a negative extglob pattern like {\ttfamily !(a$\vert$B)}. Multiple {\ttfamily !} characters at the start of a pattern will negate the pattern multiple times.

If a pattern starts with {\ttfamily \#}, then it is treated as a comment, and will not match anything. Use {\ttfamily \textbackslash{}\#} to match a literal {\ttfamily \#} at the start of a line, or set the {\ttfamily nocomment} flag to suppress this behavior.

The double-\/star character {\ttfamily $\ast$$\ast$} is supported by default, unless the {\ttfamily noglobstar} flag is set. This is supported in the manner of bsdglob and bash 4.\+1, where {\ttfamily $\ast$$\ast$} only has special significance if it is the only thing in a path part. That is, {\ttfamily a/$\ast$$\ast$/b} will match {\ttfamily a/x/y/b}, but {\ttfamily a/$\ast$$\ast$b} will not.

If an escaped pattern has no matches, and the {\ttfamily nonull} flag is set, then minimatch.\+match returns the pattern as-\/provided, rather than interpreting the character escapes. For example, {\ttfamily minimatch.\+match(\mbox{[}\mbox{]}, \char`\"{}\textbackslash{}\textbackslash{}$\ast$a\textbackslash{}\textbackslash{}?\char`\"{})} will return {\ttfamily \char`\"{}\textbackslash{}\textbackslash{}$\ast$a\textbackslash{}\textbackslash{}?\char`\"{}} rather than {\ttfamily \char`\"{}$\ast$a?\char`\"{}}. This is akin to setting the {\ttfamily nullglob} option in bash, except that it does not resolve escaped pattern characters.

If brace expansion is not disabled, then it is performed before any other interpretation of the glob pattern. Thus, a pattern like {\ttfamily +(a$\vert$\{b),c)\}}, which would not be valid in bash or zsh, is expanded {\bfseries first} into the set of {\ttfamily +(a$\vert$b)} and {\ttfamily +(a$\vert$c)}, and those patterns are checked for validity. Since those two are valid, matching proceeds. 