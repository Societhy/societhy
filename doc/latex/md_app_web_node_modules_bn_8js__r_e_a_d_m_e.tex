\begin{quote}
Big\+Num in pure javascript \end{quote}


\href{http://travis-ci.org/indutny/bn.js}{\tt }

\subsection*{Install}

{\ttfamily npm install -\/-\/save bn.\+js}

\subsection*{Usage}


\begin{DoxyCode}
const BN = require('bn.js');

var a = new BN('dead', 16);
var b = new BN('101010', 2);

var res = a.add(b);
console.log(res.toString(10));  // 57047
\end{DoxyCode}


\subsection*{Notation}

\subsubsection*{Prefixes}

There are several prefixes to instructions that affect the way the work. Here is the list of them in the order of appearance in the function name\+:


\begin{DoxyItemize}
\item {\ttfamily i} -\/ perform operation in-\/place, storing the result in the host object (on which the method was invoked). Might be used to avoid number allocation costs
\item {\ttfamily u} -\/ unsigned, ignore the sign of operands when performing operation, or always return positive value. Second case applies to reduction operations like {\ttfamily mod()}. In such cases if the result will be negative -\/ modulo will be added to the result to make it positive
\end{DoxyItemize}

\subsubsection*{Postfixes}

The only available postfix at the moment is\+:


\begin{DoxyItemize}
\item {\ttfamily n} -\/ which means that the argument of the function must be a plain Java\+Script number
\end{DoxyItemize}

\subsubsection*{Examples}


\begin{DoxyItemize}
\item {\ttfamily a.\+iadd(b)} -\/ perform addition on {\ttfamily a} and {\ttfamily b}, storing the result in {\ttfamily a}
\item {\ttfamily a.\+pmod(b)} -\/ reduce {\ttfamily a} modulo {\ttfamily b}, returning positive value
\item {\ttfamily a.\+iushln(13)} -\/ shift bits of {\ttfamily a} left by 13
\end{DoxyItemize}

\subsection*{Instructions}

Prefixes/postfixes are put in parens at the of the line. {\ttfamily endian} -\/ could be either {\ttfamily le} (little-\/endian) or {\ttfamily be} (big-\/endian).

\subsubsection*{Utilities}


\begin{DoxyItemize}
\item {\ttfamily a.\+clone()} -\/ clone number
\item {\ttfamily a.\+to\+Array(endian, length)} -\/ convert to byte array, and optionally zero pad to length, throwing if already exceeding
\item {\ttfamily a.\+to\+String(base, padding)} -\/ convert to base-\/string and pad with zeroes
\item {\ttfamily a.\+bit\+Length()} -\/ get number of bits occupied
\item {\ttfamily a.\+zero\+Bits()} -\/ return number of less-\/significant consequent zero bits (example\+: {\ttfamily 1010000} has 4 zero bits)
\item {\ttfamily a.\+byte\+Length()} -\/ return number of bytes occupied
\item {\ttfamily a.\+is\+Even()} -\/ no comments
\item {\ttfamily a.\+is\+Odd()} -\/ no comments
\item {\ttfamily a.\+cmp(b)} -\/ compare numbers and return {\ttfamily -\/1} ({\ttfamily $<$}), {\ttfamily 0} ({\ttfamily ==}), or {\ttfamily 1} ({\ttfamily $>$}) depending on the comparison result ({\ttfamily ucmp}, {\ttfamily cmpn})
\end{DoxyItemize}

\subsubsection*{Arithmetics}


\begin{DoxyItemize}
\item {\ttfamily a.\+neg()} -\/ negate sign ({\ttfamily i})
\item {\ttfamily a.\+abs()} -\/ absolute value ({\ttfamily i})
\item {\ttfamily a.\+add(b)} -\/ addition ({\ttfamily i}, {\ttfamily n})
\item {\ttfamily a.\+sub(b)} -\/ subtraction ({\ttfamily i}, {\ttfamily n})
\item {\ttfamily a.\+mul(b)} -\/ multiply ({\ttfamily i}, {\ttfamily n})
\item {\ttfamily a.\+sqr()} -\/ square ({\ttfamily i})
\item {\ttfamily a.\+pow(b)} -\/ raise {\ttfamily a} to the power of {\ttfamily b}
\item {\ttfamily a.\+div(b)} -\/ divide ({\ttfamily divn}, {\ttfamily idivn})
\item {\ttfamily a.\+mod(b)} -\/ reduct ({\ttfamily u}, {\ttfamily n})
\item {\ttfamily a.\+div\+Round(b)} -\/ rounded division
\end{DoxyItemize}

\subsubsection*{Bit operations}


\begin{DoxyItemize}
\item {\ttfamily a.\+or(b)} -\/ or ({\ttfamily i}, {\ttfamily u})
\item {\ttfamily a.\+and(b)} -\/ and ({\ttfamily i}, {\ttfamily u}, {\ttfamily andln}) (N\+O\+TE\+: {\ttfamily andln} is going to be replaced with {\ttfamily andn} in future)
\item {\ttfamily a.\+xor(b)} -\/ xor ({\ttfamily i}, {\ttfamily u})
\item {\ttfamily a.\+setn(b)} -\/ set specified bit to {\ttfamily 1}
\item {\ttfamily a.\+shln(b)} -\/ shift left ({\ttfamily i}, {\ttfamily u})
\item {\ttfamily a.\+shrn(b)} -\/ shift right ({\ttfamily i}, {\ttfamily u})
\item {\ttfamily a.\+testn(b)} -\/ test if specified bit is set
\item {\ttfamily a.\+maskn(b)} -\/ clear bits with indexes higher or equal to {\ttfamily b} ({\ttfamily i})
\item {\ttfamily a.\+bincn(b)} -\/ add {\ttfamily 1 $<$$<$ b} to the number
\end{DoxyItemize}

\subsubsection*{Reduction}


\begin{DoxyItemize}
\item {\ttfamily a.\+gcd(b)} -\/ G\+CD
\item {\ttfamily a.\+egcd(b)} -\/ Extended G\+CD results ({\ttfamily \{ a\+: ..., b\+: ..., gcd\+: ... \}})
\item {\ttfamily a.\+invm(b)} -\/ inverse {\ttfamily a} modulo {\ttfamily b}
\end{DoxyItemize}

\subsection*{Fast reduction}

When doing lots of reductions using the same modulo, it might be beneficial to use some tricks\+: like \href{https://en.wikipedia.org/wiki/Montgomery_modular_multiplication}{\tt Montgomery multiplication}, or using special algorithm for \href{https://en.wikipedia.org/wiki/Mersenne_prime}{\tt Mersenne Prime}.

\subsubsection*{Reduction context}

To enable this tricks one should create a reduction context\+:


\begin{DoxyCode}
var red = BN.red(num);
\end{DoxyCode}
 where {\ttfamily num} is just a BN instance.

Or\+:


\begin{DoxyCode}
var red = BN.red(primeName);
\end{DoxyCode}


Where {\ttfamily prime\+Name} is either of these \href{https://en.wikipedia.org/wiki/Mersenne_prime}{\tt Mersenne Primes}\+:


\begin{DoxyItemize}
\item {\ttfamily \textquotesingle{}k256\textquotesingle{}}
\item {\ttfamily \textquotesingle{}p224\textquotesingle{}}
\item {\ttfamily \textquotesingle{}p192\textquotesingle{}}
\item {\ttfamily \textquotesingle{}p25519\textquotesingle{}}
\end{DoxyItemize}

Or\+:


\begin{DoxyCode}
var red = BN.mont(num);
\end{DoxyCode}


To reduce numbers with \href{https://en.wikipedia.org/wiki/Mersenne_prime}{\tt Montgomery trick}. {\ttfamily .mont()} is generally faster than {\ttfamily .red(num)}, but slower than {\ttfamily B\+N.\+red(prime\+Name)}.

\subsubsection*{Converting numbers}

Before performing anything in reduction context -\/ numbers should be converted to it. Usually, this means that one should\+:


\begin{DoxyItemize}
\item Convert inputs to reducted ones
\item Operate on them in reduction context
\item Convert outputs back from the reduction context
\end{DoxyItemize}

Here is how one may convert numbers to {\ttfamily red}\+:


\begin{DoxyCode}
var redA = a.toRed(red);
\end{DoxyCode}
 Where {\ttfamily red} is a reduction context created using instructions above

Here is how to convert them back\+:


\begin{DoxyCode}
var a = redA.fromRed();
\end{DoxyCode}


\subsubsection*{Red instructions}

Most of the instructions from the very start of this readme have their counterparts in red context\+:


\begin{DoxyItemize}
\item {\ttfamily a.\+red\+Add(b)}, {\ttfamily a.\+red\+I\+Add(b)}
\item {\ttfamily a.\+red\+Sub(b)}, {\ttfamily a.\+red\+I\+Sub(b)}
\item {\ttfamily a.\+red\+Shl(num)}
\item {\ttfamily a.\+red\+Mul(b)}, {\ttfamily a.\+red\+I\+Mul(b)}
\item {\ttfamily a.\+red\+Sqr()}, {\ttfamily a.\+red\+I\+Sqr()}
\item {\ttfamily a.\+red\+Sqrt()} -\/ square root modulo reduction context\textquotesingle{}s prime
\item {\ttfamily a.\+red\+Invm()} -\/ modular inverse of the number
\item {\ttfamily a.\+red\+Neg()}
\item {\ttfamily a.\+red\+Pow(b)} -\/ modular exponentiation
\end{DoxyItemize}

\subsection*{L\+I\+C\+E\+N\+SE}

This software is licensed under the M\+IT License.

Copyright Fedor Indutny, 2015.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 