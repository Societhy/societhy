{\ttfamily \hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}} and {\ttfamily Nan\+::\+Async\+Progress\+Worker} are helper classes that make working with asynchronous code easier.


\begin{DoxyItemize}
\item \href{#api_nan_async_worker}{\tt {\bfseries {\ttfamily Nan\+::\+Async\+Worker}}}
\item \href{#api_nan_async_progress_worker}{\tt {\bfseries {\ttfamily Nan\+::\+Async\+Progress\+Worker}}}
\item \href{#api_nan_async_queue_worker}{\tt {\bfseries {\ttfamily Nan\+::\+Async\+Queue\+Worker}}}
\end{DoxyItemize}

\label{_api_nan_async_worker}%
 \subsubsection*{\hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}}

{\ttfamily \hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}} is an {\itshape abstract} class that you can subclass to have much of the annoying asynchronous queuing and handling taken care of for you. It can even store arbitrary V8 objects for you and have them persist while the asynchronous work is in progress.

Definition\+:


\begin{DoxyCode}
\{c++\}
class AsyncWorker \{
 public:
  explicit AsyncWorker(Callback *callback\_);

  virtual ~AsyncWorker();

  virtual void WorkComplete();

  void SaveToPersistent(const char *key, const v8::Local<v8::Value> &value);

  void SaveToPersistent(const v8::Local<v8::String> &key,
                        const v8::Local<v8::Value> &value);

  void SaveToPersistent(uint32\_t index,
                        const v8::Local<v8::Value> &value);

  v8::Local<v8::Value> GetFromPersistent(const char *key) const;

  v8::Local<v8::Value> GetFromPersistent(const v8::Local<v8::String> &key) const;

  v8::Local<v8::Value> GetFromPersistent(uint32\_t index) const;

  virtual void Execute() = 0;

  uv\_work\_t request;

  virtual void Destroy();

 protected:
  Persistent<v8::Object> persistentHandle;

  Callback *callback;

  virtual void HandleOKCallback();

  virtual void HandleErrorCallback();

  void SetErrorMessage(const char *msg);

  const char* ErrorMessage();
\};
\end{DoxyCode}


\label{_api_nan_async_progress_worker}%
 \subsubsection*{\hyperlink{class_nan_1_1_async_progress_worker_base}{Nan\+::\+Async\+Progress\+Worker\+Base} \& Nan\+::\+Async\+Progress\+Worker}

{\ttfamily \hyperlink{class_nan_1_1_async_progress_worker_base}{Nan\+::\+Async\+Progress\+Worker\+Base}} is an {\itshape abstract} class template that extends {\ttfamily \hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}} and adds additional progress reporting callbacks that can be used during the asynchronous work execution to provide progress data back to Java\+Script.

Previously the definiton of {\ttfamily Nan\+::\+Async\+Progress\+Worker} only allowed sending {\ttfamily const char} data. Now extending {\ttfamily Nan\+::\+Async\+Progress\+Worker} will yield an instance of the implicit {\ttfamily \hyperlink{class_nan_1_1_async_progress_worker_base}{Nan\+::\+Async\+Progress\+Worker\+Base}} template with type {\ttfamily $<$char$>$} for compatibility.

Definition\+:


\begin{DoxyCode}
\{c++\}
template<class T>
class AsyncProgressWorkerBase<T> : public AsyncWorker \{
 public:
  explicit AsyncProgressWorker(Callback *callback\_);

  virtual ~AsyncProgressWorker();

  void WorkProgress();

  class ExecutionProgress \{
   public:
    void Signal() const;
    void Send(const T* data, size\_t size) const;
  \};

  virtual void Execute(const ExecutionProgress& progress) = 0;

  virtual void HandleProgressCallback(const T *data, size\_t size) = 0;

  virtual void Destroy();

typedef AsyncProgressWorkerBase<T> AsyncProgressWorker;
\end{DoxyCode}


\label{_api_nan_async_queue_worker}%
 \subsubsection*{Nan\+::\+Async\+Queue\+Worker}

{\ttfamily Nan\+::\+Async\+Queue\+Worker} will run a {\ttfamily \hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}} asynchronously via libuv. Both the {\ttfamily execute} and {\ttfamily after\+\_\+work} steps are taken care of for you. Most of the logic for this is embedded in {\ttfamily \hyperlink{class_nan_1_1_async_worker}{Nan\+::\+Async\+Worker}}.

Definition\+:


\begin{DoxyCode}
\{c++\}
void AsyncQueueWorker(AsyncWorker *);
\end{DoxyCode}
 