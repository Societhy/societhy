\href{http://unshift.io}{\tt }\href{http://browsenpm.org/package/ultron}{\tt }\href{https://travis-ci.org/unshiftio/ultron}{\tt }\href{https://david-dm.org/unshiftio/ultron}{\tt }\href{https://coveralls.io/r/unshiftio/ultron?branch=master}{\tt }\href{http://webchat.freenode.net/?channels=unshift}{\tt }

Ultron is a high-\/intelligence robot. It gathers intelligence so it can start improving upon his rudimentary design. It will learn your event emitting patterns and find ways to exterminate them. Allowing you to remove only the event emitters that {\bfseries you} assigned and not the ones that your users or developers assigned. This can prevent race conditions, memory leaks and even file descriptor leaks from ever happening as you won\textquotesingle{}t remove clean up processes.

\subsection*{Installation}

The module is designed to be used in browsers using browserify and in Node.\+js. You can install the module through the public npm registry by running the following command in C\+LI\+:


\begin{DoxyCode}
npm install --save ultron
\end{DoxyCode}


\subsection*{Usage}

In all examples we assume that you\textquotesingle{}ve required the library as following\+:


\begin{DoxyCode}
'use strict';

var Ultron = require('ultron');
\end{DoxyCode}


Now that we\textquotesingle{}ve required the library we can construct our first {\ttfamily Ultron} instance. The constructor requires one argument which should be the {\ttfamily Event\+Emitter} instance that we need to operate upon. This can be the {\ttfamily Event\+Emitter} module that ships with Node.\+js or {\ttfamily Event\+Emitter3} or anything else as long as it follow the same A\+PI and internal structure as these 2. So with that in mind we can create the instance\+:


\begin{DoxyCode}
//
// For the sake of this example we're going to construct an empty EventEmitter
//
var EventEmitter = require('events').EventEmitter; // or require('eventmitter3');
var events = new EventEmitter();

var ultron = new Ultron(events);
\end{DoxyCode}


You can now use the following A\+PI\textquotesingle{}s from the Ultron instance\+:

\subsubsection*{Ultron.\+on}

Register a new event listener for the given event. It follows the exact same A\+PI as {\ttfamily Event\+Emitter.\+on} but it will return itself instead of returning the Event\+Emitter instance. If you are using Event\+Emitter3 it also supports the context param\+:


\begin{DoxyCode}
ultron.on('event-name', handler, \{ custom: 'function context' \});
\end{DoxyCode}


\subsubsection*{Ultron.\+once}

Exactly the same as the \href{#ultronon}{\tt Ultron.\+on} but it only allows the execution once.

\subsubsection*{Ultron.\+remove}

This is where all the magic happens and the safe removal starts. This function accepts different argument styles\+:


\begin{DoxyItemize}
\item No arguments, assume that all events need to be removed so it will work as {\ttfamily remove\+All\+Listeners()} A\+PI.
\item 1 argument, when it\textquotesingle{}s a string it will be split on and {\ttfamily ,} to create a list of events that need to be cleared.
\item Multiple arguments, we assume that they are all names of events that need to be cleared.
\end{DoxyItemize}


\begin{DoxyCode}
ultron.remove('foo, bar baz');        // Removes foo, bar and baz.
ultron.remove('foo', 'bar', 'baz');   // Removes foo, bar and baz.
ultron.remove();                      // Removes everything.
\end{DoxyCode}


If you just want to remove a single event listener using a function reference you can still use the Event\+Emitter\textquotesingle{}s {\ttfamily remove\+Listener(event, fn)} A\+PI\+:


\begin{DoxyCode}
function foo() \{\}

ulton.on('foo', foo);
events.removeListener('foo', foo);
\end{DoxyCode}


\subsection*{License}

M\+IT 