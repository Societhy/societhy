Writable stream that concatenates all the data from a stream and calls a callback with the result. Use this when you want to collect all the data from a stream into a single buffer.

\href{https://travis-ci.org/maxogden/concat-stream}{\tt }

\href{https://nodei.co/npm/concat-stream/}{\tt }

\subsubsection*{description}

Streams emit many buffers. If you want to collect all of the buffers, and when the stream ends concatenate all of the buffers together and receive a single buffer then this is the module for you.

Only use this if you know you can fit all of the output of your stream into a single Buffer (e.\+g. in R\+AM).

There are also {\ttfamily object\+Mode} streams that emit things other than Buffers, and you can concatenate these too. See below for details.

\subsection*{Related}

{\ttfamily stream-\/each} is part of the \href{https://github.com/maxogden/mississippi}{\tt mississippi stream utility collection} which includes more useful stream modules similar to this one.

\subsubsection*{examples}

\paragraph*{Buffers}


\begin{DoxyCode}
var fs = require('fs')
var concat = require('concat-stream')

var readStream = fs.createReadStream('cat.png')
var concatStream = concat(gotPicture)

readStream.on('error', handleError)
readStream.pipe(concatStream)

function gotPicture(imageBuffer) \{
  // imageBuffer is all of `cat.png` as a node.js Buffer
\}

function handleError(err) \{
  // handle your error appropriately here, e.g.:
  console.error(err) // print the error to STDERR
  process.exit(1) // exit program with non-zero exit code
\}
\end{DoxyCode}


\paragraph*{Arrays}


\begin{DoxyCode}
var write = concat(function(data) \{\})
write.write([1,2,3])
write.write([4,5,6])
write.end()
// data will be [1,2,3,4,5,6] in the above callback
\end{DoxyCode}


\paragraph*{Uint8\+Arrays}


\begin{DoxyCode}
var write = concat(function(data) \{\})
var a = new Uint8Array(3)
a[0] = 97; a[1] = 98; a[2] = 99
write.write(a)
write.write('!')
write.end(Buffer('!!1'))
\end{DoxyCode}


See {\ttfamily test/} for more examples

\section*{methods}


\begin{DoxyCode}
var concat = require('concat-stream')
\end{DoxyCode}


\subsection*{var writable = concat(opts=\{\}, cb)}

Return a {\ttfamily writable} stream that will fire {\ttfamily cb(data)} with all of the data that was written to the stream. Data can be written to {\ttfamily writable} as strings, Buffers, arrays of byte integers, and Uint8\+Arrays.

By default {\ttfamily concat-\/stream} will give you back the same data type as the type of the first buffer written to the stream. Use {\ttfamily opts.\+encoding} to set what format {\ttfamily data} should be returned as, e.\+g. if you if you don\textquotesingle{}t want to rely on the built-\/in type checking or for some other reason.


\begin{DoxyItemize}
\item {\ttfamily string} -\/ get a string
\item {\ttfamily buffer} -\/ get back a Buffer
\item {\ttfamily array} -\/ get an array of byte integers
\item {\ttfamily uint8array}, {\ttfamily u8}, {\ttfamily uint8} -\/ get back a Uint8\+Array
\item {\ttfamily object}, get back an array of Objects
\end{DoxyItemize}

If you don\textquotesingle{}t specify an encoding, and the types can\textquotesingle{}t be inferred (e.\+g. you write things that aren\textquotesingle{}t in the list above), it will try to convert concat them into a {\ttfamily Buffer}.

If nothing is written to {\ttfamily writable} then {\ttfamily data} will be an empty array {\ttfamily \mbox{[}\mbox{]}}.

\section*{error handling}

{\ttfamily concat-\/stream} does not handle errors for you, so you must handle errors on whatever streams you pipe into {\ttfamily concat-\/stream}. This is a general rule when programming with node.\+js streams\+: always handle errors on each and every stream. Since {\ttfamily concat-\/stream} is not itself a stream it does not emit errors.

We recommend using \href{https://npmjs.org/end-of-stream}{\tt {\ttfamily end-\/of-\/stream}} or \href{https://npmjs.org/pump}{\tt {\ttfamily pump}} for writing error tolerant stream code.

\section*{license}

M\+IT L\+I\+C\+E\+N\+SE 