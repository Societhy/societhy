Optimist is a node.\+js library for option parsing for people who hate option parsing. More specifically, this module is for people who like all the --bells and -\/whistlz of program usage but think optstrings are a waste of time.

With optimist, option parsing doesn\textquotesingle{}t have to suck (as much).

\href{http://travis-ci.org/substack/node-optimist}{\tt }

\section*{examples }

\subsection*{With Optimist, the options are just a hash! No optstrings attached. }

xup.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist').argv;

if (argv.rif - 5 * argv.xup > 7.138) \{
    console.log('Buy more riffiwobbles');
\}
else \{
    console.log('Sell the xupptumblers');
\}
\end{DoxyCode}




 \begin{DoxyVerb}$ ./xup.js --rif=55 --xup=9.52
Buy more riffiwobbles

$ ./xup.js --rif 12 --xup 8.1
Sell the xupptumblers
\end{DoxyVerb}




\subsection*{But wait! There\textquotesingle{}s more! You can do short options\+: }

short.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist').argv;
console.log('(%d,%d)', argv.x, argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./short.js -x 10 -y 21
(10,21)
\end{DoxyVerb}


\subsection*{And booleans, both long and short (and grouped)\+: }

bool.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var util = require('util');
var argv = require('optimist').argv;

if (argv.s) \{
    util.print(argv.fr ? 'Le chat dit: ' : 'The cat says: ');
\}
console.log(
    (argv.fr ? 'miaou' : 'meow') + (argv.p ? '.' : '')
);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./bool.js -s
The cat says: meow

$ ./bool.js -sp
The cat says: meow.

$ ./bool.js -sp --fr
Le chat dit: miaou.
\end{DoxyVerb}


\subsection*{And non-\/hypenated options too! Just use {\ttfamily argv.\+\_\+}! }

nonopt.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist').argv;
console.log('(%d,%d)', argv.x, argv.y);
console.log(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./nonopt.js -x 6.82 -y 3.35 moo
(6.82,3.35)
[ 'moo' ]

$ ./nonopt.js foo -x 0.54 bar -y 1.12 baz
(0.54,1.12)
[ 'foo', 'bar', 'baz' ]
\end{DoxyVerb}


\subsection*{Plus, Optimist comes with .usage() and .demand()! }

divide.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .usage('Usage: $0 -x [num] -y [num]')
    .demand(['x','y'])
    .argv;

console.log(argv.x / argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./divide.js -x 55 -y 11
5

$ node ./divide.js -x 4.91 -z 2.51
Usage: node ./divide.js -x [num] -y [num]

Options:
  -x  [required]
  -y  [required]

Missing required arguments: y
\end{DoxyVerb}


\subsection*{E\+V\+EN M\+O\+RE H\+O\+LY C\+OW }

default\+\_\+singles.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .default('x', 10)
    .default('y', 10)
    .argv
;
console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_singles.js -x 5
15
\end{DoxyVerb}


default\+\_\+hash.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .default(\{ x : 10, y : 10 \})
    .argv
;
console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_hash.js -y 7
17
\end{DoxyVerb}


\subsection*{And if you really want to get all descriptive about it... }

boolean\+\_\+single.\+js


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .boolean('v')
    .argv
;
console.dir(argv);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_single.js -v foo bar baz
true
[ 'bar', 'baz', 'foo' ]
\end{DoxyVerb}


boolean\+\_\+double.\+js


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .boolean(['x','y','z'])
    .argv
;
console.dir([ argv.x, argv.y, argv.z ]);
console.dir(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_double.js -x -z one two three
[ true, false, true ]
[ 'one', 'two', 'three' ]
\end{DoxyVerb}


\subsection*{Optimist is here to help... }

You can describe parameters for help messages and set aliases. Optimist figures out how to format a handy help string automatically.

line\+\_\+count.\+js


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('optimist')
    .usage('Count the lines in a file.\(\backslash\)nUsage: $0')
    .demand('f')
    .alias('f', 'file')
    .describe('f', 'Load a file')
    .argv
;

var fs = require('fs');
var s = fs.createReadStream(argv.file);

var lines = 0;
s.on('data', function (buf) \{
    lines += buf.toString().match(/\(\backslash\)n/g).length;
\});

s.on('end', function () \{
    console.log(lines);
\});
\end{DoxyCode}




 \begin{DoxyVerb}$ node line_count.js
Count the lines in a file.
Usage: node ./line_count.js

Options:
  -f, --file  Load a file  [required]

Missing required arguments: f

$ node line_count.js --file line_count.js 
20

$ node line_count.js -f line_count.js 
20
\end{DoxyVerb}


\section*{methods }

By itself,

````javascript require(\textquotesingle{}optimist\textquotesingle{}).argv `````

will use {\ttfamily process.\+argv} array to construct the {\ttfamily argv} object.

You can pass in the {\ttfamily process.\+argv} yourself\+:


\begin{DoxyCode}
require('optimist')([ '-x', '1', '-y', '2' ]).argv
\end{DoxyCode}


or use .parse() to do the same thing\+:


\begin{DoxyCode}
require('optimist').parse([ '-x', '1', '-y', '2' ])
\end{DoxyCode}


The rest of these methods below come in just before the terminating {\ttfamily .argv}.

\subsection*{.alias(key, alias) }

Set key names as equivalent such that updates to a key will propagate to aliases and vice-\/versa.

Optionally {\ttfamily .alias()} can take an object that maps keys to aliases.

\subsection*{.default(key, value) }

Set {\ttfamily argv\mbox{[}key\mbox{]}} to {\ttfamily value} if no option was specified on {\ttfamily process.\+argv}.

Optionally {\ttfamily .default()} can take an object that maps keys to default values.

\subsection*{.demand(key) }

If {\ttfamily key} is a string, show the usage information and exit if {\ttfamily key} wasn\textquotesingle{}t specified in {\ttfamily process.\+argv}.

If {\ttfamily key} is a number, demand at least as many non-\/option arguments, which show up in {\ttfamily argv.\+\_\+}.

If {\ttfamily key} is an Array, demand each element.

\subsection*{.describe(key, desc) }

Describe a {\ttfamily key} for the generated usage information.

Optionally {\ttfamily .describe()} can take an object that maps keys to descriptions.

\subsection*{.options(key, opt) }

Instead of chaining together {\ttfamily .alias().demand().default()}, you can specify keys in {\ttfamily opt} for each of the chainable methods.

For example\+:


\begin{DoxyCode}
var argv = require('optimist')
    .options('f', \{
        alias : 'file',
        default : '/etc/passwd',
    \})
    .argv
;
\end{DoxyCode}


is the same as


\begin{DoxyCode}
var argv = require('optimist')
    .alias('f', 'file')
    .default('f', '/etc/passwd')
    .argv
;
\end{DoxyCode}


Optionally {\ttfamily .options()} can take an object that maps keys to {\ttfamily opt} parameters.

\subsection*{.usage(message) }

Set a usage message to show which commands to use. Inside {\ttfamily message}, the string {\ttfamily \$0} will get interpolated to the current script name or node command for the present script similar to how {\ttfamily \$0} works in bash or perl.

\subsection*{.check(fn) }

Check that certain conditions are met in the provided arguments.

If {\ttfamily fn} throws or returns {\ttfamily false}, show the thrown error, usage information, and exit.

\subsection*{.boolean(key) }

Interpret {\ttfamily key} as a boolean. If a non-\/flag option follows {\ttfamily key} in {\ttfamily process.\+argv}, that string won\textquotesingle{}t get set as the value of {\ttfamily key}.

If {\ttfamily key} never shows up as a flag in {\ttfamily process.\+arguments}, {\ttfamily argv\mbox{[}key\mbox{]}} will be {\ttfamily false}.

If {\ttfamily key} is an Array, interpret all the elements as booleans.

\subsection*{.string(key) }

Tell the parser logic not to interpret {\ttfamily key} as a number or boolean. This can be useful if you need to preserve leading zeros in an input.

If {\ttfamily key} is an Array, interpret all the elements as strings.

\subsection*{.wrap(columns) }

Format usage output to wrap at {\ttfamily columns} many columns.

\subsection*{.help() }

Return the generated usage string.

\subsection*{.show\+Help(fn=console.\+error) }

Print the usage data using {\ttfamily fn} for printing.

\subsection*{.parse(args) }

Parse {\ttfamily args} instead of {\ttfamily process.\+argv}. Returns the {\ttfamily argv} object.

\subsection*{.argv }

Get the arguments as a plain old object.

Arguments without a corresponding flag show up in the {\ttfamily argv.\+\_\+} array.

The script name or node command is available at {\ttfamily argv.\$0} similarly to how {\ttfamily \$0} works in bash or perl.

\section*{parsing tricks }

\subsection*{stop parsing }

Use {\ttfamily -\/-\/} to stop parsing flags and stuff the remainder into {\ttfamily argv.\+\_\+}. \begin{DoxyVerb}$ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4
{ _: [ '-c', '3', '-d', '4' ],
  '$0': 'node ./examples/reflect.js',
  a: 1,
  b: 2 }
\end{DoxyVerb}


\subsection*{negate fields }

If you want to explicity set a field to false instead of just leaving it undefined or to override a default you can do {\ttfamily -\/-\/no-\/key}. \begin{DoxyVerb}$ node examples/reflect.js -a --no-b
{ _: [],
  '$0': 'node ./examples/reflect.js',
  a: true,
  b: false }
\end{DoxyVerb}


\subsection*{numbers }

Every argument that looks like a number ({\ttfamily !is\+NaN(Number(arg))}) is converted to one. This way you can just {\ttfamily net.\+create\+Connection(argv.\+port)} and you can add numbers out of {\ttfamily argv} with {\ttfamily +} without having that mean concatenation, which is super frustrating.

\subsection*{duplicates }

If you specify a flag multiple times it will get turned into an array containing all the values in order. \begin{DoxyVerb}$ node examples/reflect.js -x 5 -x 8 -x 0
{ _: [],
  '$0': 'node ./examples/reflect.js',
    x: [ 5, 8, 0 ] }
\end{DoxyVerb}


\subsection*{dot notation }

When you use dots ({\ttfamily .}s) in argument names, an implicit object path is assumed. This lets you organize arguments into nested objects. \begin{DoxyVerb} $ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5
 { _: [],
   '$0': 'node ./examples/reflect.js',
     foo: { bar: { baz: 33 }, quux: 5 } }
\end{DoxyVerb}


\section*{installation }

With \href{http://github.com/isaacs/npm}{\tt npm}, just do\+: npm install optimist

or clone this project on github\+: \begin{DoxyVerb}git clone http://github.com/substack/node-optimist.git
\end{DoxyVerb}


To run the tests with \href{http://github.com/visionmedia/expresso}{\tt expresso}, just do\+: \begin{DoxyVerb}expresso
\end{DoxyVerb}


\section*{inspired By }

This module is loosely inspired by Perl\textquotesingle{}s \href{http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm}{\tt Getopt\+::\+Casual}. 