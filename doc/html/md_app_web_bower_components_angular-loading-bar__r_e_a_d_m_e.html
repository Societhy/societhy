<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: angular-loading-bar</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">angular-loading-bar </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The idea is simple: Add a loading bar / progress bar whenever an XHR request goes out in angular. Multiple requests within the same time period get bundled together such that each response increments the progress bar by the appropriate amount.</p>
<p>This is mostly cool because you simply include it in your app, and it works. There's no complicated setup, and no need to maintain the state of the loading bar; it's all handled automatically by the interceptor.</p>
<p><b>Requirements:</b> AngularJS 1.2+</p>
<p><b>File Size:</b> 2.4Kb minified, 0.5Kb gzipped</p>
<h2>Usage:</h2>
<ol type="1">
<li><p class="startli">include the loading bar as a dependency for your app. If you want animations, include <code>ngAnimate</code> as well. <em>note: ngAnimate is optional</em></p>
<p class="startli">```js angular.module('myApp', ['angular-loading-bar', 'ngAnimate']) ```</p>
</li>
<li>include the supplied CSS file (or create your own).</li>
<li>That's it &ndash; you're done!</li>
</ol>
<p>#### via bower: </p><div class="fragment"><div class="line">$ bower install angular-loading-bar</div></div><!-- fragment --><p> #### via npm: </p><div class="fragment"><div class="line">$ npm install angular-loading-bar</div></div><!-- fragment --><h2>Why I created this</h2>
<p>There are a couple projects similar to this out there, but none were ideal for me. All implementations I've seen require that you maintain state on behalf of the loading bar. In other words, you're setting the value of the loading/progress bar manually from potentially many different locations. This becomes complicated when you have a very large application with several services all making independant XHR requests. It becomes even more complicated if you want these services to be loosly coupled.</p>
<p>Additionally, Angular was created as a highly testable framework, so it pains me to see Angular modules without tests. That is not the case here as this loading bar ships with 100% code coverage.</p>
<p><b>Goals for this project:</b></p>
<ol type="1">
<li>Make it automatic</li>
<li>Unit tests, 100% coverage</li>
<li>Must work well with ngAnimate</li>
<li>Must be styled via external CSS (not inline)</li>
<li>No jQuery dependencies</li>
</ol>
<h2>Configuration</h2>
<h4>Turn the spinner on or off:</h4>
<p>The insertion of the spinner can be controlled through configuration. It's on by default, but if you'd like to turn it off, simply configure the service:</p>
<div class="fragment"><div class="line">angular.module(&#39;myApp&#39;, [&#39;angular-loading-bar&#39;])</div><div class="line">  .config([&#39;cfpLoadingBarProvider&#39;, function(cfpLoadingBarProvider) {</div><div class="line">    cfpLoadingBarProvider.includeSpinner = false;</div><div class="line">  }])</div></div><!-- fragment --><h4>Turn the loading bar on or off:</h4>
<p>Like the spinner configuration above, the loading bar can also be turned off for cases where you only want the spinner:</p>
<div class="fragment"><div class="line">angular.module(&#39;myApp&#39;, [&#39;angular-loading-bar&#39;])</div><div class="line">  .config([&#39;cfpLoadingBarProvider&#39;, function(cfpLoadingBarProvider) {</div><div class="line">    cfpLoadingBarProvider.includeBar = false;</div><div class="line">  }])</div></div><!-- fragment --><h4>Latency Threshold</h4>
<p>By default, the loading bar will only display after it has been waiting for a response for over 100ms. This helps keep things feeling snappy, and avoids the annoyingness of showing a loading bar every few seconds on really chatty applications. This threshold is totally configurable:</p>
<div class="fragment"><div class="line">angular.module(&#39;myApp&#39;, [&#39;angular-loading-bar&#39;])</div><div class="line">  .config([&#39;cfpLoadingBarProvider&#39;, function(cfpLoadingBarProvider) {</div><div class="line">    cfpLoadingBarProvider.latencyThreshold = 500;</div><div class="line">  }])</div></div><!-- fragment --><h4>Ignoring particular XHR requests:</h4>
<p>The loading bar can also be forced to ignore certain requests, for example, when long-polling or periodically sending debugging information back to the server.</p>
<div class="fragment"><div class="line">// ignore particular $http requests:</div><div class="line">$http.get(&#39;/status&#39;, {</div><div class="line">  ignoreLoadingBar: true</div><div class="line">});</div></div><!-- fragment --><div class="fragment"><div class="line">// ignore particular $resource requests:</div><div class="line">.factory(&#39;Restaurant&#39;, function($resource) {</div><div class="line">  return $resource(&#39;/api/restaurant/:id&#39;, {id: &#39;@id&#39;}, {</div><div class="line">    query: {</div><div class="line">      method: &#39;GET&#39;,</div><div class="line">      isArray: true,</div><div class="line">      ignoreLoadingBar: true</div><div class="line">    }</div><div class="line">  });</div><div class="line">});</div></div><!-- fragment --><h2>How it works:</h2>
<p>This library is split into two modules, an $http <code>interceptor</code>, and a <code>service</code>:</p>
<p><b>Interceptor</b> The interceptor simply listens for all outgoing XHR requests, and then instructs the loadingBar service to start, stop, and increment accordingly. There is no public API for the interceptor. It can be used stand-alone by including <code>cfp.loadingBarInterceptor</code> as a dependency for your module.</p>
<p><b>Service</b> The service is responsible for the presentation of the loading bar. It injects the loading bar into the DOM, adjusts the width whenever <code>set()</code> is called, and <code>complete()</code>s the whole show by removing the loading bar from the DOM.</p>
<h2>Service API (advanced usage)</h2>
<p>Under normal circumstances you won't need to use this. However, if you wish to use the loading bar without the interceptor, you can do that as well. Simply include the loading bar service as a dependency instead of the main <code>angular-loading-bar</code> module:</p>
<div class="fragment"><div class="line">angular.module(&#39;myApp&#39;, [&#39;cfp.loadingBar&#39;])</div></div><!-- fragment --><div class="fragment"><div class="line">cfpLoadingBar.start();</div><div class="line">// will insert the loading bar into the DOM, and display its progress at 1%.</div><div class="line">// It will automatically call `inc()` repeatedly to give the illusion that the page load is progressing.</div><div class="line"></div><div class="line">cfpLoadingBar.inc();</div><div class="line">// increments the loading bar by a random amount.</div><div class="line">// It is important to note that the auto incrementing will begin to slow down as</div><div class="line">// the progress increases.  This is to prevent the loading bar from appearing</div><div class="line">// completed (or almost complete) before the XHR request has responded. </div><div class="line"></div><div class="line">cfpLoadingBar.set(0.3) // Set the loading bar to 30%</div><div class="line">cfpLoadingBar.status() // Returns the loading bar&#39;s progress.</div><div class="line">// -&gt; 0.3</div><div class="line"></div><div class="line">cfpLoadingBar.complete()</div><div class="line">// Set the loading bar&#39;s progress to 100%, and then remove it from the DOM.</div></div><!-- fragment --><h2>Events</h2>
<p>The loading bar broadcasts the following events over $rootScope allowing further customization:</p>
<p>**<code>cfpLoadingBar:loading</code>** triggered upon each XHR request that is not already cached</p>
<p>**<code>cfpLoadingBar:loaded</code>** triggered each time an XHR request recieves a response (either successful or error)</p>
<p>**<code>cfpLoadingBar:started</code>** triggered once upon the first XHR request. Will trigger again if another request goes out after <code>cfpLoadingBar:completed</code> has triggered.</p>
<p>**<code>cfpLoadingBar:completed</code>** triggered once when the all XHR requests have returned (either successfully or not)</p>
<h2>Credits:</h2>
<p>Credit goes to <a href="https://github.com/rstacruz">rstacruz</a> for his excellent <a href="https://github.com/rstacruz/nprogress">nProgress</a>.</p>
<h2>License:</h2>
<p>Licensed under the MIT license </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
