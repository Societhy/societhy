<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Object Wrappers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Object Wrappers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <code><a class="el" href="class_object_wrap.html">ObjectWrap</a></code> class can be used to make wrapped C++ objects and a factory of wrapped objects.</p>
<ul>
<li><a href="#api_nan_object_wrap"><b><code>Nan::ObjectWrap</code></b></a></li>
</ul>
<p><a class="anchor" id="api_nan_object_wrap"></a> </p><h3><a class="el" href="class_nan_1_1_object_wrap.html">Nan::ObjectWrap()</a></h3>
<p>A reimplementation of <code>node::ObjectWrap</code> that adds some API not present in older versions of Node. Should be preferred over <code>node::ObjectWrap</code> in all cases for consistency.</p>
<p>Definition:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">class ObjectWrap {</div><div class="line"> public:</div><div class="line">  ObjectWrap();</div><div class="line"></div><div class="line">  virtual ~ObjectWrap();</div><div class="line"></div><div class="line">  template &lt;class T&gt;</div><div class="line">  static inline T* Unwrap(v8::Local&lt;v8::Object&gt; handle);</div><div class="line"></div><div class="line">  inline v8::Local&lt;v8::Object&gt; handle();</div><div class="line"></div><div class="line">  inline Nan::Persistent&lt;v8::Object&gt;&amp; persistent();</div><div class="line"></div><div class="line"> protected:</div><div class="line">  inline void Wrap(v8::Local&lt;v8::Object&gt; handle);</div><div class="line"></div><div class="line">  inline void MakeWeak();</div><div class="line"></div><div class="line">  /* Ref() marks the object as being attached to an event loop.</div><div class="line">   * Refed objects will not be garbage collected, even if</div><div class="line">   * all references are lost.</div><div class="line">   */</div><div class="line">  virtual void Ref();</div><div class="line"></div><div class="line">  /* Unref() marks an object as detached from the event loop.  This is its</div><div class="line">   * default state.  When an object with a &quot;weak&quot; reference changes from</div><div class="line">   * attached to detached state it will be freed. Be careful not to access</div><div class="line">   * the object after making this call as it might be gone!</div><div class="line">   * (A &quot;weak reference&quot; means an object that only has a</div><div class="line">   * persistant handle.)</div><div class="line">   *</div><div class="line">   * DO NOT CALL THIS FROM DESTRUCTOR</div><div class="line">   */</div><div class="line">  virtual void Unref();</div><div class="line"></div><div class="line">  int refs_;  // ro</div><div class="line">};</div></div><!-- fragment --><p>See the Node documentation on <a href="https://nodejs.org/api/addons.html#addons_wrapping_c_objects">Wrapping C++ Objects</a> for more details.</p>
<h3>This vs. Holder</h3>
<p>When calling <code>Unwrap</code>, it is important that the argument is indeed some JavaScript object which got wrapped by a <code>Wrap</code> call for this class or any derived class. The <code>Signature</code> installed by <a href="methods.md#api_nan_set_prototype_method"><code>Nan::SetPrototypeMethod()</code></a> does ensure that <code>info.Holder()</code> is just such an instance. In Node 0.12 and later, <code>info.This()</code> will also be of such a type, since otherwise the invocation will get rejected. However, in Node 0.10 and before it was possible to invoke a method on a JavaScript object which just had the extension type in its prototype chain. In such a situation, calling <code>Unwrap</code> on <code>info.This()</code> will likely lead to a failed assertion causing a crash, but could lead to even more serious corruption.</p>
<p>On the other hand, calling <code>Unwrap</code> in an <a href="methods.md#api_nan_set_accessor">accessor</a> should not use <code>Holder()</code> if the accessor is defined on the prototype. So either define your accessors on the instance template, or use <code>This()</code> after verifying that it is indeed a valid object.</p>
<h3>Examples</h3>
<h4>Basic</h4>
<div class="fragment"><div class="line">{c++}</div><div class="line">class MyObject : public Nan::ObjectWrap {</div><div class="line"> public:</div><div class="line">  static NAN_MODULE_INIT(Init) {</div><div class="line">    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);</div><div class="line">    tpl-&gt;SetClassName(Nan::New(&quot;MyObject&quot;).ToLocalChecked());</div><div class="line">    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);</div><div class="line"></div><div class="line">    SetPrototypeMethod(tpl, &quot;getHandle&quot;, GetHandle);</div><div class="line">    SetPrototypeMethod(tpl, &quot;getValue&quot;, GetValue);</div><div class="line"></div><div class="line">    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());</div><div class="line">    Nan::Set(target, Nan::New(&quot;MyObject&quot;).ToLocalChecked(),</div><div class="line">      Nan::GetFunction(tpl).ToLocalChecked());</div><div class="line">  }</div><div class="line"></div><div class="line"> private:</div><div class="line">  explicit MyObject(double value = 0) : value_(value) {}</div><div class="line">  ~MyObject() {}</div><div class="line"></div><div class="line">  static NAN_METHOD(New) {</div><div class="line">    if (info.IsConstructCall()) {</div><div class="line">      double value = info[0]-&gt;IsUndefined() ? 0 : Nan::To&lt;double&gt;(info[0]).FromJust();</div><div class="line">      MyObject *obj = new MyObject(value);</div><div class="line">      obj-&gt;Wrap(info.This());</div><div class="line">      info.GetReturnValue().Set(info.This());</div><div class="line">    } else {</div><div class="line">      const int argc = 1;</div><div class="line">      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};</div><div class="line">      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());</div><div class="line">      info.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  static NAN_METHOD(GetHandle) {</div><div class="line">    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());</div><div class="line">    info.GetReturnValue().Set(obj-&gt;handle());</div><div class="line">  }</div><div class="line"></div><div class="line">  static NAN_METHOD(GetValue) {</div><div class="line">    MyObject* obj = Nan::ObjectWrap::Unwrap&lt;MyObject&gt;(info.Holder());</div><div class="line">    info.GetReturnValue().Set(obj-&gt;value_);</div><div class="line">  }</div><div class="line"></div><div class="line">  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {</div><div class="line">    static Nan::Persistent&lt;v8::Function&gt; my_constructor;</div><div class="line">    return my_constructor;</div><div class="line">  }</div><div class="line"></div><div class="line">  double value_;</div><div class="line">};</div><div class="line"></div><div class="line">NODE_MODULE(objectwrapper, MyObject::Init)</div></div><!-- fragment --><p>To use in Javascript:</p>
<div class="fragment"><div class="line">var objectwrapper = require(&#39;bindings&#39;)(&#39;objectwrapper&#39;);</div><div class="line"></div><div class="line">var obj = new objectwrapper.MyObject(5);</div><div class="line">console.log(&#39;Should be 5: &#39; + obj.getValue());</div></div><!-- fragment --><h4>Factory of wrapped objects</h4>
<div class="fragment"><div class="line">{c++}</div><div class="line">class MyFactoryObject : public Nan::ObjectWrap {</div><div class="line"> public:</div><div class="line">  static NAN_MODULE_INIT(Init) {</div><div class="line">    v8::Local&lt;v8::FunctionTemplate&gt; tpl = Nan::New&lt;v8::FunctionTemplate&gt;(New);</div><div class="line">    tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);</div><div class="line"></div><div class="line">    Nan::SetPrototypeMethod(tpl, &quot;getValue&quot;, GetValue);</div><div class="line"></div><div class="line">    constructor().Reset(Nan::GetFunction(tpl).ToLocalChecked());</div><div class="line">  }</div><div class="line"></div><div class="line">  static NAN_METHOD(NewInstance) {</div><div class="line">    v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());</div><div class="line">    double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;</div><div class="line">    const int argc = 1;</div><div class="line">    v8::Local&lt;v8::Value&gt; argv[1] = {Nan::New(value)};</div><div class="line">    info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());</div><div class="line">  }</div><div class="line"></div><div class="line">  // Needed for the next example:</div><div class="line">  inline double value() const {</div><div class="line">    return value_;</div><div class="line">  }</div><div class="line"></div><div class="line"> private:</div><div class="line">  explicit MyFactoryObject(double value = 0) : value_(value) {}</div><div class="line">  ~MyFactoryObject() {}</div><div class="line"></div><div class="line">  static NAN_METHOD(New) {</div><div class="line">    if (info.IsConstructCall()) {</div><div class="line">      double value = info[0]-&gt;IsNumber() ? Nan::To&lt;double&gt;(info[0]).FromJust() : 0;</div><div class="line">      MyFactoryObject * obj = new MyFactoryObject(value);</div><div class="line">      obj-&gt;Wrap(info.This());</div><div class="line">      info.GetReturnValue().Set(info.This());</div><div class="line">    } else {</div><div class="line">      const int argc = 1;</div><div class="line">      v8::Local&lt;v8::Value&gt; argv[argc] = {info[0]};</div><div class="line">      v8::Local&lt;v8::Function&gt; cons = Nan::New(constructor());</div><div class="line">      info.GetReturnValue().Set(Nan::NewInstance(cons, argc, argv).ToLocalChecked());</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  static NAN_METHOD(GetValue) {</div><div class="line">    MyFactoryObject* obj = ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(info.Holder());</div><div class="line">    info.GetReturnValue().Set(obj-&gt;value_);</div><div class="line">  }</div><div class="line"></div><div class="line">  static inline Nan::Persistent&lt;v8::Function&gt; &amp; constructor() {</div><div class="line">    static Nan::Persistent&lt;v8::Function&gt; my_constructor;</div><div class="line">    return my_constructor;</div><div class="line">  }</div><div class="line"></div><div class="line">  double value_;</div><div class="line">};</div><div class="line"></div><div class="line">NAN_MODULE_INIT(Init) {</div><div class="line">  MyFactoryObject::Init(target);</div><div class="line">  Nan::Set(target,</div><div class="line">    Nan::New&lt;v8::String&gt;(&quot;newFactoryObjectInstance&quot;).ToLocalChecked(),</div><div class="line">    Nan::GetFunction(</div><div class="line">      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()</div><div class="line">  );</div><div class="line">}</div><div class="line"></div><div class="line">NODE_MODULE(wrappedobjectfactory, Init)</div></div><!-- fragment --><p>To use in Javascript:</p>
<div class="fragment"><div class="line">var wrappedobjectfactory = require(&#39;bindings&#39;)(&#39;wrappedobjectfactory&#39;);</div><div class="line"></div><div class="line">var obj = wrappedobjectfactory.newFactoryObjectInstance(10);</div><div class="line">console.log(&#39;Should be 10: &#39; + obj.getValue());</div></div><!-- fragment --><h4>Passing wrapped objects around</h4>
<p>Use the <code>MyFactoryObject</code> class above along with the following:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">static NAN_METHOD(Sum) {</div><div class="line">  Nan::MaybeLocal&lt;v8::Object&gt; maybe1 = Nan::To&lt;v8::Object&gt;(info[0]);</div><div class="line">  Nan::MaybeLocal&lt;v8::Object&gt; maybe2 = Nan::To&lt;v8::Object&gt;(info[1]);</div><div class="line"></div><div class="line">  // Quick check:</div><div class="line">  if (maybe1.IsEmpty() || maybe2.IsEmpty()) {</div><div class="line">    // return value is undefined by default</div><div class="line">    return;</div><div class="line">  }</div><div class="line"></div><div class="line">  MyFactoryObject* obj1 =</div><div class="line">    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe1.ToLocalChecked());</div><div class="line">  MyFactoryObject* obj2 =</div><div class="line">    Nan::ObjectWrap::Unwrap&lt;MyFactoryObject&gt;(maybe2.ToLocalChecked());</div><div class="line"></div><div class="line">  info.GetReturnValue().Set(Nan::New&lt;v8::Number&gt;(obj1-&gt;value() + obj2-&gt;value()));</div><div class="line">}</div><div class="line"></div><div class="line">NAN_MODULE_INIT(Init) {</div><div class="line">  MyFactoryObject::Init(target);</div><div class="line">  Nan::Set(target,</div><div class="line">    Nan::New&lt;v8::String&gt;(&quot;newFactoryObjectInstance&quot;).ToLocalChecked(),</div><div class="line">    Nan::GetFunction(</div><div class="line">      Nan::New&lt;v8::FunctionTemplate&gt;(MyFactoryObject::NewInstance)).ToLocalChecked()</div><div class="line">  );</div><div class="line">  Nan::Set(target,</div><div class="line">    Nan::New&lt;v8::String&gt;(&quot;sum&quot;).ToLocalChecked(),</div><div class="line">    Nan::GetFunction(Nan::New&lt;v8::FunctionTemplate&gt;(Sum)).ToLocalChecked()</div><div class="line">  );</div><div class="line">}</div><div class="line"></div><div class="line">NODE_MODULE(myaddon, Init)</div></div><!-- fragment --><p>To use in Javascript:</p>
<div class="fragment"><div class="line">var myaddon = require(&#39;bindings&#39;)(&#39;myaddon&#39;);</div><div class="line"></div><div class="line">var obj1 = myaddon.newFactoryObjectInstance(5);</div><div class="line">var obj2 = myaddon.newFactoryObjectInstance(10);</div><div class="line">console.log(&#39;sum of object values: &#39; + myaddon.sum(obj1, obj2));</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
