<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: socket.io</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">socket.io </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/socketio/socket.io"></a> <a href="https://david-dm.org/socketio/socket.io"></a> <a href="https://david-dm.org/socketio/socket.io#info=devDependencies"></a> <a href="https://www.npmjs.com/package/socket.io"></a> </p><div class="image">
<img src="https://img.shields.io/npm/dm/socket.io.svg?style=flat" alt="Downloads"/>
</div>
<p> <a href="http://slack.socket.io"></a></p>
<h2>How to use</h2>
<p>The following example attaches socket.io to a plain Node.JS HTTP server listening on port <code>3000</code>.</p>
<div class="fragment"><div class="line">var server = require(&#39;http&#39;).createServer();</div><div class="line">var io = require(&#39;socket.io&#39;)(server);</div><div class="line">io.on(&#39;connection&#39;, function(client){</div><div class="line">  client.on(&#39;event&#39;, function(data){});</div><div class="line">  client.on(&#39;disconnect&#39;, function(){});</div><div class="line">});</div><div class="line">server.listen(3000);</div></div><!-- fragment --><h3>Standalone</h3>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.on(&#39;connection&#39;, function(client){});</div><div class="line">io.listen(3000);</div></div><!-- fragment --><h3>In conjunction with Express</h3>
<p>Starting with <b>3.0</b>, express applications have become request handler functions that you pass to <code>http</code> or <code>http</code> <code>Server</code> instances. You need to pass the <code>Server</code> to <code>socket.io</code>, and not the express application function.</p>
<div class="fragment"><div class="line">var app = require(&#39;express&#39;)();</div><div class="line">var server = require(&#39;http&#39;).createServer(app);</div><div class="line">var io = require(&#39;socket.io&#39;)(server);</div><div class="line">io.on(&#39;connection&#39;, function(){ /* … */ });</div><div class="line">server.listen(3000);</div></div><!-- fragment --><h3>In conjunction with Koa</h3>
<p>Like Express.JS, Koa works by exposing an application as a request handler function, but only by calling the <code>callback</code> method.</p>
<div class="fragment"><div class="line">var app = require(&#39;koa&#39;)();</div><div class="line">var server = require(&#39;http&#39;).createServer(app.callback());</div><div class="line">var io = require(&#39;socket.io&#39;)(server);</div><div class="line">io.on(&#39;connection&#39;, function(){ /* … */ });</div><div class="line">server.listen(3000);</div></div><!-- fragment --><h2>API</h2>
<h3>Server</h3>
<p>Exposed by `require('socket.io')`.</p>
<h3>Server()</h3>
<p>Creates a new <code>Server</code>. Works with and without <code>new</code>:</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">// or</div><div class="line">var Server = require(&#39;socket.io&#39;);</div><div class="line">var io = new Server();</div></div><!-- fragment --><h3>Server(opts:Object)</h3>
<p>Optionally, the first or second argument (see below) of the <code>Server</code> constructor can be an options object.</p>
<p>The following options are supported:</p>
<ul>
<li><code>serveClient</code> sets the value for Server::serveClient()</li>
<li><code>path</code> sets the value for Server::path()</li>
</ul>
<p>The same options passed to socket.io are always passed to the <code>engine.io</code> <code>Server</code> that gets created. See engine.io <a href="https://github.com/socketio/engine.io#methods-1">options</a> as reference.</p>
<h3>Server(srv:http::Server, opts:Object)</h3>
<p>Creates a new <code>Server</code> and attaches it to the given <code>srv</code>. Optionally <code>opts</code> can be passed.</p>
<h3>Server(port:Number, opts:Object)</h3>
<p>Binds socket.io to a new <code>http.Server</code> that listens on <code>port</code>.</p>
<h3>Server::serveClient(v:Boolean):Server</h3>
<p>If <code>v</code> is <code>true</code> the attached server (see <code>Server::attach</code>) will serve the client files. Defaults to <code>true</code>.</p>
<p>This method has no effect after <code>attach</code> is called.</p>
<div class="fragment"><div class="line">// pass a server and the `serveClient` option</div><div class="line">var io = require(&#39;socket.io&#39;)(http, { serveClient: false });</div><div class="line"></div><div class="line">// or pass no server and then you can call the method</div><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.serveClient(false);</div><div class="line">io.attach(http);</div></div><!-- fragment --><p>If no arguments are supplied this method returns the current value.</p>
<h3>Server::path(v:String):Server</h3>
<p>Sets the path <code>v</code> under which <code>engine.io</code> and the static files will be served. Defaults to <code>/socket.io</code>.</p>
<p>If no arguments are supplied this method returns the current value.</p>
<h3>Server::adapter(v:Adapter):Server</h3>
<p>Sets the adapter <code>v</code>. Defaults to an instance of the <code>Adapter</code> that ships with socket.io which is memory based. See <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>.</p>
<p>If no arguments are supplied this method returns the current value.</p>
<h3>Server::origins(v:String):Server</h3>
<p>Sets the allowed origins <code>v</code>. Defaults to any origins being allowed.</p>
<p>If no arguments are supplied this method returns the current value.</p>
<h3>Server::origins(v:Function):Server</h3>
<p>Sets the allowed origins as dynamic function. Function takes two arguments <code>origin:String</code> and <code>callback(error, success)</code>, where <code>success</code> is a boolean value indicating whether origin is allowed or not.</p>
<p><b>Potential drawbacks</b>:</p><ul>
<li>in some situations, when it is not possible to determine <code>origin</code> it may have value of <code>*</code></li>
<li>As this function will be executed for every request, it is advised to make this function work as fast as possible</li>
<li>If <code>socket.io</code> is used together with <code>Express</code>, the CORS headers will be affected only for <code>socket.io</code> requests. For Express can use <a href="https://github.com/expressjs/cors">cors</a>.</li>
</ul>
<h3>Server::sockets:Namespace</h3>
<p>The default (<code>/</code>) namespace.</p>
<h3>Server::attach(srv:http::Server, opts:Object):Server</h3>
<p>Attaches the <code>Server</code> to an engine.io instance on <code>srv</code> with the supplied <code>opts</code> (optionally).</p>
<h3>Server::attach(port:Number, opts:Object):Server</h3>
<p>Attaches the <code>Server</code> to an engine.io instance that is bound to <code>port</code> with the given <code>opts</code> (optionally).</p>
<h3>Server::listen</h3>
<p>Synonym of <code>Server::attach</code>.</p>
<h3>Server::bind(srv:engine::Server):Server</h3>
<p>Advanced use only. Binds the server to a specific engine.io <code>Server</code> (or compatible API) instance.</p>
<h3>Server::onconnection(socket:engine::Socket):Server</h3>
<p>Advanced use only. Creates a new <code>socket.io</code> client from the incoming engine.io (or compatible API) <code>socket</code>.</p>
<h3>Server::of(nsp:String):Namespace</h3>
<p>Initializes and retrieves the given <code>Namespace</code> by its pathname identifier <code>nsp</code>.</p>
<p>If the namespace was already initialized it returns it immediately.</p>
<h3>Server::emit</h3>
<p>Emits an event to all connected clients. The following two are equivalent:</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.sockets.emit(&#39;an event sent to all connected clients&#39;);</div><div class="line">io.emit(&#39;an event sent to all connected clients&#39;);</div></div><!-- fragment --><p>For other available methods, see <code>Namespace</code> below.</p>
<h3>Server::close([fn:Function])</h3>
<p>Closes socket.io server.</p>
<p>The optional <code>fn</code> is passed to the <code>server.close([callback])</code> method of the core <code>net</code> module and is called on error or when all connections are closed. The callback is expected to implement the common single argument <code>err</code> signature (if any).</p>
<div class="fragment"><div class="line">var Server = require(&#39;socket.io&#39;);</div><div class="line">var PORT   = 3030;</div><div class="line">var server = require(&#39;http&#39;).Server();</div><div class="line"></div><div class="line">var io = Server(PORT);</div><div class="line"></div><div class="line">io.close(); // Close current server</div><div class="line"></div><div class="line">server.listen(PORT); // PORT is free to use</div><div class="line"></div><div class="line">io = Server(server);</div></div><!-- fragment --><h3>Server::use</h3>
<p>See <code>Namespace::use</code> below.</p>
<h3>Namespace</h3>
<p>Represents a pool of sockets connected under a given scope identified by a pathname (eg: <code>/chat</code>).</p>
<p>By default the client always connects to <code>/</code>.</p>
<h4>Events</h4>
<ul>
<li><p class="startli"><code>connection</code> / <code>connect</code>. Fired upon a connection.</p>
<p class="startli">Parameters:</p><ul>
<li><code>Socket</code> the incoming socket.</li>
</ul>
</li>
</ul>
<h3>Namespace::name:String</h3>
<p>The namespace identifier property.</p>
<h3>Namespace::connected:Object&lt;Socket&gt;</h3>
<p>Hash of <code>Socket</code> objects that are connected to this namespace indexed by <code>id</code>.</p>
<h3>Namespace::clients(fn:Function)</h3>
<p>Gets a list of client IDs connected to this namespace (across all nodes if applicable).</p>
<p>An example to get all clients in a namespace:</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.of(&#39;/chat&#39;).clients(function(error, clients){</div><div class="line">  if (error) throw error;</div><div class="line">  console.log(clients); // =&gt; [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]</div><div class="line">});</div></div><!-- fragment --><p>An example to get all clients in namespace's room:</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.of(&#39;/chat&#39;).in(&#39;general&#39;).clients(function(error, clients){</div><div class="line">  if (error) throw error;</div><div class="line">  console.log(clients); // =&gt; [Anw2LatarvGVVXEIAAAD]</div><div class="line">});</div></div><!-- fragment --><p>As with broadcasting, the default is all clients from the default namespace ('/'):</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.clients(function(error, clients){</div><div class="line">  if (error) throw error;</div><div class="line">  console.log(clients); // =&gt; [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]</div><div class="line">});</div></div><!-- fragment --><h3>Namespace::use(fn:Function):Namespace</h3>
<p>Registers a middleware, which is a function that gets executed for every incoming <code>Socket</code>, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.use(function(socket, next){</div><div class="line">  if (socket.request.headers.cookie) return next();</div><div class="line">  next(new Error(&#39;Authentication error&#39;));</div><div class="line">});</div></div><!-- fragment --><p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>
<h3>Socket</h3>
<p>A <code>Socket</code> is the fundamental class for interacting with browser clients. A <code>Socket</code> belongs to a certain <code>Namespace</code> (by default <code>/</code>) and uses an underlying <code>Client</code> to communicate.</p>
<p>It should be noted the <code>Socket</code> doesn't relate directly to the actual underlying TCP/IP <code>socket</code> and it is only the name of the class.</p>
<h3>Socket::use(fn:Function):Socket</h3>
<p>Registers a middleware, which is a function that gets executed for every incoming <code>Packet</code> and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.on(&#39;connection&#39;, function(socket){</div><div class="line">  socket.use(function(packet, next){</div><div class="line">    if (packet.doge === true) return next();</div><div class="line">    next(new Error(&#39;Not a doge error&#39;));</div><div class="line">});</div></div><!-- fragment --><p>Errors passed to middleware callbacks are sent as special <code>error</code> packets to clients.</p>
<h3>Socket::rooms:Object</h3>
<p>A hash of strings identifying the rooms this client is in, indexed by room name.</p>
<h3>Socket::client:Client</h3>
<p>A reference to the underlying <code>Client</code> object.</p>
<h3>Socket::conn:Socket</h3>
<p>A reference to the underlying <code>Client</code> transport connection (engine.io <code>Socket</code> object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.</p>
<h3>Socket::request:Request</h3>
<p>A getter proxy that returns the reference to the <code>request</code> that originated the underlying engine.io <code>Client</code>. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>
<h3>Socket::id:String</h3>
<p>A unique identifier for the session, that comes from the underlying <code>Client</code>.</p>
<h3>Socket::emit(name:String[, …]):Socket</h3>
<p>Emits an event identified by the string <code>name</code> to the client. Any other parameters can be included.</p>
<p>All datastructures are supported, including <code>Buffer</code>. JavaScript functions can't be serialized/deserialized.</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.on(&#39;connection&#39;, function(client){</div><div class="line">  client.emit(&#39;an event&#39;, { some: &#39;data&#39; });</div><div class="line">});</div></div><!-- fragment --><h3>Socket::join(name:String[, fn:Function]):Socket</h3>
<p>Adds the client to the <code>room</code>, and fires optionally a callback <code>fn</code> with <code>err</code> signature (if any).</p>
<p>The client is automatically a member of a room identified with its session id (see <code>Socket::id</code>).</p>
<p>The mechanics of joining rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server::adapter</code> above), defaulting to <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>.</p>
<h3>Socket::leave(name:String[, fn:Function]):Socket</h3>
<p>Removes the client from <code>room</code>, and fires optionally a callback <code>fn</code> with <code>err</code> signature (if any).</p>
<p><b>Rooms are left automatically upon disconnection</b>.</p>
<p>The mechanics of leaving rooms are handled by the <code>Adapter</code> that has been configured (see <code>Server::adapter</code> above), defaulting to <a href="https://github.com/socketio/socket.io-adapter">socket.io-adapter</a>.</p>
<h3>Socket::to(room:String):Socket</h3>
<p>Sets a modifier for a subsequent event emission that the event will only be <em>broadcasted</em> to clients that have joined the given <code>room</code>.</p>
<p>To emit to multiple rooms, you can call <code>to</code> several times.</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.on(&#39;connection&#39;, function(client){</div><div class="line">  client.to(&#39;others&#39;).emit(&#39;an event&#39;, { some: &#39;data&#39; });</div><div class="line">});</div></div><!-- fragment --><h3>Socket::in(room:String):Socket</h3>
<p>Same as <code>Socket::to</code></p>
<h3>Socket::compress(v:Boolean):Socket</h3>
<p>Sets a modifier for a subsequent event emission that the event data will only be <em>compressed</em> if the value is <code>true</code>. Defaults to <code>true</code> when you don't call the method.</p>
<div class="fragment"><div class="line">var io = require(&#39;socket.io&#39;)();</div><div class="line">io.on(&#39;connection&#39;, function(client){</div><div class="line">  client.compress(false).emit(&#39;an event&#39;, { some: &#39;data&#39; });</div><div class="line">});</div></div><!-- fragment --><h3>Socket::disconnect(close:Boolean):Socket</h3>
<p>Disconnects this client. If value of close is <code>true</code>, closes the underlying connection. Otherwise, it just disconnects the namespace.</p>
<h4>Events</h4>
<ul>
<li><code>disconnect</code><ul>
<li>Fired upon disconnection.</li>
<li><b>Arguments</b><ul>
<li><code>String</code>: the reason of the disconnection (either client or server-side)</li>
</ul>
</li>
</ul>
</li>
<li><code>error</code><ul>
<li>Fired when an error occurs.</li>
<li><b>Arguments</b><ul>
<li><code>Object</code>: error data</li>
</ul>
</li>
</ul>
</li>
<li><code>disconnecting</code><ul>
<li>Fired when the client is going to be disconnected (but hasn't left its <code>rooms</code> yet).</li>
<li><b>Arguments</b><ul>
<li><code>String</code>: the reason of the disconnection (either client or server-side)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>These are reserved events (along with <code>connect</code>, <code>newListener</code> and <code>removeListener</code>) which cannot be used as event names.</p>
<h3>Client</h3>
<p>The <code>Client</code> class represents an incoming transport (engine.io) connection. A <code>Client</code> can be associated with many multiplexed <code>Socket</code>s that belong to different <code>Namespace</code>s.</p>
<h3>Client::conn</h3>
<p>A reference to the underlying <code>engine.io</code> <code>Socket</code> connection.</p>
<h3>Client::request</h3>
<p>A getter proxy that returns the reference to the <code>request</code> that originated the engine.io connection. Useful for accessing request headers such as <code>Cookie</code> or <code>User-Agent</code>.</p>
<h2>Debug / logging</h2>
<p>Socket.IO is powered by <a href="https://github.com/visionmedia/debug">debug</a>. In order to see all the debug output, run your app with the environment variable <code>DEBUG</code> including the desired scope.</p>
<p>To see the output from all of Socket.IO's debugging scopes you can use:</p>
<div class="fragment"><div class="line">DEBUG=socket.io* node myapp</div></div><!-- fragment --><h2>Testing</h2>
<div class="fragment"><div class="line">npm test</div></div><!-- fragment --><p> This runs the <code>gulp</code> task <code>test</code>. By default the test will be run with the source code in <code>lib</code> directory.</p>
<p>Set the environmental variable <code>TEST_VERSION</code> to <code>compat</code> to test the transpiled es5-compat version of the code.</p>
<p>The <code>gulp</code> task <code>test</code> will always transpile the source code into es5 and export to <code>dist</code> first before running the test.</p>
<h2>License</h2>
<p>[MIT](LICENSE) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
