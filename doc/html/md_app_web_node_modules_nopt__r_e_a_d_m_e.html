<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If you want to write an option parser, and have it be good, there are two ways to do it. The Right Way, and the Wrong Way.</p>
<p>The Wrong Way is to sit down and write an option parser. We've all done that.</p>
<p>The Right Way is to write some complex configurable program with so many options that you go half-insane just trying to manage them all, and put it off with duct-tape solutions until you see exactly to the core of the problem, and finally snap and write an awesome option parser.</p>
<p>If you want to write an option parser, don't write an option parser. Write a package manager, or a source control system, or a service restarter, or an operating system. You probably won't end up with a good one of those, but if you don't give up, and you are relentless and diligent enough in your procrastination, you may just end up with a very nice option parser.</p>
<h2>USAGE</h2>
<pre class="fragment">// my-program.js
var nopt = require("nopt")
  , Stream = require("stream").Stream
  , path = require("path")
  , knownOpts = { "foo" : [String, null]
                , "bar" : [Stream, Number]
                , "baz" : path
                , "bloo" : [ "big", "medium", "small" ]
                , "flag" : Boolean
                , "pick" : Boolean
                , "many" : [String, Array]
                }
  , shortHands = { "foofoo" : ["--foo", "Mr. Foo"]
                 , "b7" : ["--bar", "7"]
                 , "m" : ["--bloo", "medium"]
                 , "p" : ["--pick"]
                 , "f" : ["--flag"]
                 }
             // everything is optional.
             // knownOpts and shorthands default to {}
             // arg list defaults to process.argv
             // slice defaults to 2
  , parsed = nopt(knownOpts, shortHands, process.argv, 2)
console.log(parsed)
</pre><p>This would give you support for any of the following:</p>
<div class="fragment"><div class="line">$ node my-program.js --foo &quot;blerp&quot; --no-flag</div><div class="line">{ &quot;foo&quot; : &quot;blerp&quot;, &quot;flag&quot; : false }</div><div class="line"></div><div class="line">$ node my-program.js ---bar 7 --foo &quot;Mr. Hand&quot; --flag</div><div class="line">{ bar: 7, foo: &quot;Mr. Hand&quot;, flag: true }</div><div class="line"></div><div class="line">$ node my-program.js --foo &quot;blerp&quot; -f -----p</div><div class="line">{ foo: &quot;blerp&quot;, flag: true, pick: true }</div><div class="line"></div><div class="line">$ node my-program.js -fp --foofoo</div><div class="line">{ foo: &quot;Mr. Foo&quot;, flag: true, pick: true }</div><div class="line"></div><div class="line">$ node my-program.js --foofoo -- -fp  # -- stops the flag parsing.</div><div class="line">{ foo: &quot;Mr. Foo&quot;, argv: { remain: [&quot;-fp&quot;] } }</div><div class="line"></div><div class="line">$ node my-program.js --blatzk 1000 -fp # unknown opts are ok.</div><div class="line">{ blatzk: 1000, flag: true, pick: true }</div><div class="line"></div><div class="line">$ node my-program.js --blatzk true -fp # but they need a value</div><div class="line">{ blatzk: true, flag: true, pick: true }</div><div class="line"></div><div class="line">$ node my-program.js --no-blatzk -fp # unless they start with &quot;no-&quot;</div><div class="line">{ blatzk: false, flag: true, pick: true }</div><div class="line"></div><div class="line">$ node my-program.js --baz b/a/z # known paths are resolved.</div><div class="line">{ baz: &quot;/Users/isaacs/b/a/z&quot; }</div><div class="line"></div><div class="line"># if Array is one of the types, then it can take many</div><div class="line"># values, and will always be an array.  The other types provided</div><div class="line"># specify what types are allowed in the list.</div><div class="line"></div><div class="line">$ node my-program.js --many 1 --many null --many foo</div><div class="line">{ many: [&quot;1&quot;, &quot;null&quot;, &quot;foo&quot;] }</div><div class="line"></div><div class="line">$ node my-program.js --many foo</div><div class="line">{ many: [&quot;foo&quot;] }</div></div><!-- fragment --><p>Read the tests at the bottom of <code>lib/nopt.js</code> for more examples of what this puppy can do.</p>
<h2>Types</h2>
<p>The following types are supported, and defined on <code>nopt.typeDefs</code></p>
<ul>
<li>String: A normal string. No parsing is done.</li>
<li>path: A file system path. Gets resolved against cwd if not absolute.</li>
<li>url: A url. If it doesn't parse, it isn't accepted.</li>
<li>Number: Must be numeric.</li>
<li>Date: Must parse as a date. If it does, and <code>Date</code> is one of the options, then it will return a Date object, not a string.</li>
<li>Boolean: Must be either <code>true</code> or <code>false</code>. If an option is a boolean, then it does not need a value, and its presence will imply <code>true</code> as the value. To negate boolean flags, do <code>--no-whatever</code> or <code>--whatever false</code></li>
<li>NaN: Means that the option is strictly not allowed. Any value will fail.</li>
<li>Stream: An object matching the "Stream" class in node. Valuable for use when validating programmatically. (npm uses this to let you supply any WriteStream on the <code>outfd</code> and <code>logfd</code> config options.)</li>
<li>Array: If <code>Array</code> is specified as one of the types, then the value will be parsed as a list of options. This means that multiple values can be specified, and that the value will always be an array.</li>
</ul>
<p>If a type is an array of values not on this list, then those are considered valid values. For instance, in the example above, the <code>--bloo</code> option can only be one of <code>"big"</code>, <code>"medium"</code>, or <code>"small"</code>, and any other value will be rejected.</p>
<p>When parsing unknown fields, <code>"true"</code>, <code>"false"</code>, and <code>"null"</code> will be interpreted as their JavaScript equivalents, and numeric values will be interpreted as a number.</p>
<p>You can also mix types and values, or multiple types, in a list. For instance <code>{ blah: [Number, null] }</code> would allow a value to be set to either a Number or null.</p>
<p>To define a new type, add it to <code>nopt.typeDefs</code>. Each item in that hash is an object with a <code>type</code> member and a <code>validate</code> method. The <code>type</code> member is an object that matches what goes in the type list. The <code>validate</code> method is a function that gets called with <code>validate(data, key, val)</code>. Validate methods should assign <code>data[key]</code> to the valid value of <code>val</code> if it can be handled properly, or return boolean <code>false</code> if it cannot.</p>
<p>You can also call <code>nopt.clean(data, types, typeDefs)</code> to clean up a config object and remove its invalid properties.</p>
<h2>Error Handling</h2>
<p>By default, nopt outputs a warning to standard error when invalid options are found. You can change this behavior by assigning a method to <code>nopt.invalidHandler</code>. This method will be called with the offending <code>nopt.invalidHandler(key, val, types)</code>.</p>
<p>If no <code>nopt.invalidHandler</code> is assigned, then it will console.error its whining. If it is assigned to boolean <code>false</code> then the warning is suppressed.</p>
<h2>Abbreviations</h2>
<p>Yes, they are supported. If you define options like this:</p>
<div class="fragment"><div class="line">{ &quot;foolhardyelephants&quot; : Boolean</div><div class="line">, &quot;pileofmonkeys&quot; : Boolean }</div></div><!-- fragment --><p>Then this will work:</p>
<div class="fragment"><div class="line">node program.js --foolhar --pil</div><div class="line">node program.js --no-f --pileofmon</div><div class="line"># etc.</div></div><!-- fragment --><h2>Shorthands</h2>
<p>Shorthands are a hash of shorter option names to a snippet of args that they expand to.</p>
<p>If multiple one-character shorthands are all combined, and the combination does not unambiguously match any other option or shorthand, then they will be broken up into their constituent parts. For example:</p>
<div class="fragment"><div class="line">{ &quot;s&quot; : [&quot;--loglevel&quot;, &quot;silent&quot;]</div><div class="line">, &quot;g&quot; : &quot;--global&quot;</div><div class="line">, &quot;f&quot; : &quot;--force&quot;</div><div class="line">, &quot;p&quot; : &quot;--parseable&quot;</div><div class="line">, &quot;l&quot; : &quot;--long&quot;</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">npm ls -sgflp</div><div class="line"># just like doing this:</div><div class="line">npm ls --loglevel silent --global --force --long --parseable</div></div><!-- fragment --><h2>The Rest of the args</h2>
<p>The config object returned by nopt is given a special member called <code>argv</code>, which is an object with the following fields:</p>
<ul>
<li><code>remain</code>: The remaining args after all the parsing has occurred.</li>
<li><code>original</code>: The args as they originally appeared.</li>
<li><code>cooked</code>: The args after flags and shorthands are expanded.</li>
</ul>
<h2>Slicing</h2>
<p>Node programs are called with more or less the exact argv as it appears in C land, after the v8 and node-specific options have been plucked off. As such, <code>argv[0]</code> is always <code>node</code> and <code>argv[1]</code> is always the JavaScript program being run.</p>
<p>That's usually not very useful to you. So they're sliced off by default. If you want them, then you can pass in <code>0</code> as the last argument, or any other number that you'd like to slice off the start of the list. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
